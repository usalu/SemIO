// @generated by protobuf-ts 2.8.2 with parameter server_grpc1,generate_dependencies
// @generated from protobuf file "model/v1/model.proto" (package "semio.model.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Quaternion } from "../../geometry/v1/geometry";
import { Point } from "../../geometry/v1/geometry";
/**
 * A pose is a static reference frame/coordinate system.
 *
 * @generated from protobuf message semio.model.v1.Pose
 */
export interface Pose {
    /**
     * Point of view (origin) from the pose (reference frame/coordinate system)
     *
     * @generated from protobuf field: semio.geometry.v1.Point point_of_view = 1;
     */
    pointOfView?: Point;
    /**
     * View (orientation) from the pose (reference frame/coordinate system)
     *
     * @generated from protobuf field: semio.geometry.v1.Quaternion view = 2;
     */
    view?: Quaternion;
}
/**
 * A representation for an element. Basically a file with some semio specific metadata.
 *
 * @generated from protobuf message semio.model.v1.Representation
 */
export interface Representation {
    /**
     * The body depends on the serialization format of the representation.
     *
     * @generated from protobuf field: bytes body = 1;
     */
    body: Uint8Array;
    /**
     * Encoding of the body
     *
     * @generated from protobuf field: semio.model.v1.Encoding encoding = 2;
     */
    encoding: Encoding;
    /**
     * Use the abbreviation of the platform. You can find that in the constants part of the package.
     *
     * @generated from protobuf field: semio.model.v1.FileType file_type = 3;
     */
    fileType: FileType;
    /**
     * Native platform of representation
     *
     * @generated from protobuf field: semio.model.v1.Platform platform = 4;
     */
    platform: Platform;
    /**
     * A description of the representation for humans to understand what the purpose of this representation is.
     *
     * @generated from protobuf field: string description = 5;
     */
    description: string;
    /**
     * Add a list of concepts that help filtering representations. This can be used for functional purpose (e.g. statical, energetical, ...) or for visualization purpose (e.g. volumetric,comic, , ...).
     *
     * @generated from protobuf field: repeated string concepts = 6;
     */
    concepts: string[];
    /**
     * Level of detail allows to further define representation details. Like name this can be used either for visualization purpose (e.g. 200 (scale 1to200)) or functional purpose (e.g level of structural detail)
     * For architectural design it is recommended to choose the scale multiplier.
     * For BIM you might want to choose:
     * 100:Conceptual
     * 200:Approximate
     * 300:Precise
     * 400:Fabriaction
     * 500:Real
     *
     * @generated from protobuf field: int32 lod = 7;
     */
    lod: number;
}
/**
 * Describes the scope of a parameter.
 *
 * @generated from protobuf message semio.model.v1.Scope
 */
export interface Scope {
    /**
     * Concept for the scope e.g Fassade, Floor
     *
     * @generated from protobuf field: string concept = 1;
     */
    concept: string;
    /**
     * Optionally define the order. Othwerwise it will be implicitly ordered by declaration order.
     *
     * @generated from protobuf field: int32 order = 2;
     */
    order: number;
}
/**
 * @generated from protobuf message semio.model.v1.Value
 */
export interface Value {
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "text";
        /**
         * @generated from protobuf field: string text = 1;
         */
        text: string;
    } | {
        oneofKind: "number";
        /**
         * @generated from protobuf field: double number = 2;
         */
        number: number;
    } | {
        oneofKind: "integerNumber";
        /**
         * @generated from protobuf field: int32 integer_number = 3;
         */
        integerNumber: number;
    } | {
        oneofKind: "naturalNumber";
        /**
         * @generated from protobuf field: uint32 natural_number = 4;
         */
        naturalNumber: number;
    } | {
        oneofKind: "point";
        /**
         * @generated from protobuf field: semio.geometry.v1.Point point = 5;
         */
        point: Point;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A parameter is a (common) object that can be used as a parameter in all platforms.
 *
 * @generated from protobuf message semio.model.v1.Parameter
 */
export interface Parameter {
    /**
     * Name of the parameter
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Optional context field to describe the context of the parameter.
     *
     * @generated from protobuf field: repeated semio.model.v1.Scope context = 2;
     */
    context: Scope[];
    /**
     * Value of the parameter.
     *
     * @generated from protobuf field: semio.model.v1.Value value = 3;
     */
    value?: Value;
}
/**
 * A plan for a prototype.
 *
 * @generated from protobuf message semio.model.v1.Plan
 */
export interface Plan {
    /**
     * The url of the prototype definition.
     *
     * @generated from protobuf field: string url = 1;
     */
    url: string;
    /**
     * Optional parameters for the prototype.
     *
     * @generated from protobuf field: repeated semio.model.v1.Parameter parameters = 2;
     */
    parameters: Parameter[];
}
/**
 * Instance information for an element.
 *
 * @generated from protobuf message semio.model.v1.Sobject
 */
export interface Sobject {
    /**
     * Id that allows to distinguish it from other sobjects.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * The (rough) pose of the element. In the layout process this will most likely be adjusted if not specified otherwise in the assembly.
     *
     * @generated from protobuf field: semio.model.v1.Pose pose = 2;
     */
    pose?: Pose;
    /**
     * The plan for the prototype.
     *
     * @generated from protobuf field: semio.model.v1.Plan plan = 3;
     */
    plan?: Plan;
    /**
     * Concept that are relevent for the sobject.
     *
     * @generated from protobuf field: repeated string concepts = 4;
     */
    concepts: string[];
}
/**
 * A link defines the parameters for a connectable.
 *
 * @generated from protobuf message semio.model.v1.Link
 */
export interface Link {
    /**
     * An optional representation protocol for the link.
     *
     * @generated from protobuf field: semio.model.v1.RepresentationProtocol representationProtocol = 1;
     */
    representationProtocol: RepresentationProtocol;
    /**
     * Optional port names to connect to. The hierarchy should matter.
     *
     * @generated from protobuf field: repeated string ports = 2;
     */
    ports: string[];
    /**
     * Optional parameters to bias the connection.
     *
     * @generated from protobuf field: repeated semio.model.v1.Parameter bias_parameters = 3;
     */
    biasParameters: Parameter[];
}
/**
 * A connectable (sobject) connects in an connection process.
 *
 * @generated from protobuf message semio.model.v1.Connectable
 */
export interface Connectable {
    /**
     * Id of connectable (sobject).
     *
     * @generated from protobuf field: string sobject_id = 1;
     */
    sobjectId: string;
    /**
     * A link for the connectable (sobject).
     *
     * @generated from protobuf field: semio.model.v1.Link link = 2;
     */
    link?: Link;
}
/**
 * An connection can be used to connect two connectables.
 *
 * @generated from protobuf message semio.model.v1.Connection
 */
export interface Connection {
    /**
     * The connecting sobject. It is interchangable with the connected.
     *
     * @generated from protobuf field: semio.model.v1.Connectable connecting = 1;
     */
    connecting?: Connectable;
    /**
     * The connected sobject. It is interchangable with the connecting.
     *
     * @generated from protobuf field: semio.model.v1.Connectable connected = 2;
     */
    connected?: Connectable;
}
/**
 * An assembly (tree) defines a subset of a layout that can be assembled unambiguously.
 *
 * @generated from protobuf message semio.model.v1.Assembly
 */
export interface Assembly {
    /**
     * The id of the sobject to place.
     *
     * @generated from protobuf field: string sobject_id = 1;
     */
    sobjectId: string;
    /**
     * The parts of an assembly (tree) are again assemblies.
     *
     * @generated from protobuf field: repeated semio.model.v1.Assembly parts = 2;
     */
    parts: Assembly[];
}
/**
 * A layout (graph) is a plan for a set of sobjects and their connections between each other.
 *
 * @generated from protobuf message semio.model.v1.Layout
 */
export interface Layout {
    /**
     * Sobjects (nodes) that are part of the layout (graph).
     *
     * @generated from protobuf field: repeated semio.model.v1.Sobject sobjects = 1;
     */
    sobjects: Sobject[];
    /**
     * Connections (edges) that are part of the layout (graph).
     *
     * @generated from protobuf field: repeated semio.model.v1.Connection connections = 2;
     */
    connections: Connection[];
    /**
     * @generated from protobuf field: semio.model.v1.LayoutStrategy strategy = 3;
     */
    strategy: LayoutStrategy;
    /**
     * Optional assemblies that can possibly unambiguously describe the layout order of sobjects.
     * Most of the time this field is only necissary when elements that don't work well together in a general way.
     * Therefore if you can update the element definitions to be more robust, rather use your time for that.
     *
     * @generated from protobuf field: repeated semio.model.v1.Assembly assemblies = 4;
     */
    assemblies: Assembly[];
}
/**
 * A prototype acts as a template from which an element can be cloned.
 *
 * @generated from protobuf message semio.model.v1.Prototype
 */
export interface Prototype {
    /**
     * The hash of the plan used for the construction of the prototype.
     *
     * @generated from protobuf field: string plan_hash = 1;
     */
    planHash: string;
    /**
     * Representations of the prototype.
     *
     * @generated from protobuf field: repeated semio.model.v1.Representation representations = 2;
     */
    representations: Representation[];
    /**
     * An optional human readable description of the prototype.
     *
     * @generated from protobuf field: string description = 3;
     */
    description: string;
}
/**
 * An element is the atom of a design. It has several representations and a pose.
 *
 * @generated from protobuf message semio.model.v1.Element
 */
export interface Element {
    /**
     * The sobject id that was used to construct the element.
     *
     * @generated from protobuf field: string sobject_id = 1;
     */
    sobjectId: string;
    /**
     * The hash of the plan for the prototype of the element.
     *
     * @generated from protobuf field: string prototype_plan_hash = 2;
     */
    prototypePlanHash: string;
    /**
     * The pose of the element instance.
     *
     * @generated from protobuf field: semio.model.v1.Pose pose = 3;
     */
    pose?: Pose; // TODO: Think of a formalization for modifiers.    // repeated Modifier modifiers = 3;}
/**
 * A design is an aggregation of elements (actually element instances).
 *
 * @generated from protobuf message semio.model.v1.Design
 */
export interface Design {
    /**
     * @generated from protobuf field: repeated semio.model.v1.Prototype prototypes = 1;
     */
    prototypes: Prototype[];
    /**
     * @generated from protobuf field: repeated semio.model.v1.Element elements = 2;
     */
    elements: Element[];
}
/**
 * A layout modification describes declaratively a layout and the layout after its modification. The rules on how to imperatively change such a layout need to be found by the transformation system.
 *
 * @generated from protobuf message semio.model.v1.LayoutModification
 */
export interface LayoutModification {
    /**
     * @generated from protobuf field: semio.model.v1.Layout context = 1;
     */
    context?: Layout;
    /**
     * @generated from protobuf field: semio.model.v1.Layout modified_context = 2;
     */
    modifiedContext?: Layout;
}
/**
 * A decision strategy holds information on how modifications are applied.
 *
 * @generated from protobuf message semio.model.v1.LayoutModificationStrategy
 */
export interface LayoutModificationStrategy {
    /**
     * The match count describes how often a layout modification should be applied. It beeing finite will make sure that the system always terminates. Make sure to set the threshold high enough.
     *
     * @generated from protobuf field: uint32 match_count = 1;
     */
    matchCount: number;
}
/**
 * A decision is a layout modification with a strategy on how to apply it to a new layout.
 *
 * @generated from protobuf message semio.model.v1.Decision
 */
export interface Decision {
    /**
     * @generated from protobuf field: semio.model.v1.LayoutModification modification = 1;
     */
    modification?: LayoutModification;
    /**
     * @generated from protobuf field: semio.model.v1.LayoutModificationStrategy strategy = 2;
     */
    strategy?: LayoutModificationStrategy;
}
/**
 * Encoding of a byte array.
 *
 * @generated from protobuf enum semio.model.v1.Encoding
 */
export enum Encoding {
    /**
     * @generated from protobuf enum value: ENCODING_TEXT_UFT8 = 0;
     */
    TEXT_UFT8 = 0,
    /**
     * @generated from protobuf enum value: ENCODING_TEXT_UFT16 = 1;
     */
    TEXT_UFT16 = 1,
    /**
     * @generated from protobuf enum value: ENCODING_TEXT_UFT32 = 2;
     */
    TEXT_UFT32 = 2,
    /**
     * @generated from protobuf enum value: ENCODING_TEXT_ASCII = 3;
     */
    TEXT_ASCII = 3,
    /**
     * Also ASCII but with further base 64 encoding of the text.
     *
     * @generated from protobuf enum value: ENCODING_TEXT_BASE64 = 4;
     */
    TEXT_BASE64 = 4
}
/**
 * @generated from protobuf enum semio.model.v1.FileType
 */
export enum FileType {
    /**
     * Native serialization according platform. Use this only when it is none of the others.
     * Often files have a platform specific extension but if you open them in a text editor you can see that they are serialized in a standard format.
     *
     * @generated from protobuf enum value: FILETYPE_NATIVE = 0;
     */
    FILETYPE_NATIVE = 0,
    /**
     * @generated from protobuf enum value: FILETYPE_JSON = 1;
     */
    FILETYPE_JSON = 1,
    /**
     * @generated from protobuf enum value: FILETYPE_XML = 2;
     */
    FILETYPE_XML = 2,
    /**
     * @generated from protobuf enum value: FILETYPE_YAML = 3;
     */
    FILETYPE_YAML = 3,
    /**
     * @generated from protobuf enum value: FILETYPE_TOML = 4;
     */
    FILETYPE_TOML = 4,
    /**
     * https://www.iso.org/standard/63141.html
     *
     * @generated from protobuf enum value: FILETYPE_STEP = 5;
     */
    FILETYPE_STEP = 5,
    /**
     * Python
     *
     * @generated from protobuf enum value: FILETYPE_PY = 6;
     */
    FILETYPE_PY = 6,
    /**
     * @generated from protobuf enum value: FILETYPE_C = 7;
     */
    FILETYPE_C = 7,
    /**
     * C++
     *
     * @generated from protobuf enum value: FILETYPE_CPP = 8;
     */
    FILETYPE_CPP = 8,
    /**
     * C#
     *
     * @generated from protobuf enum value: FILETYPE_CSHARP = 9;
     */
    FILETYPE_CSHARP = 9,
    /**
     * Golang
     *
     * @generated from protobuf enum value: FILETYPE_GO = 10;
     */
    FILETYPE_GO = 10,
    /**
     * @generated from protobuf enum value: FILETYPE_RUST = 11;
     */
    FILETYPE_RUST = 11
}
/**
 * Platform. Constants are encoded with pattern LICENSE [3] + OWNERTYPE [2] + OWNERID [3] + PLATFORMID [2]
 * LICENSE (if possible) after https://spdx.org/licenses/:
 * 0:AGPL-3.0-or-later,
 * 50:GPL-3.0+,51:GPL-3.0,52:GPL-2.0+,53:GPL-2.0
 * 100:LGPL-3.0-or-later,101:LGPL-3.0-only
 * 150:MIT,160:Apache-2.0,
 * 170:0BSD
 * 190:EnergyPlus
 * 214:Closed
 * OWNER starting with OWNERTYPE:
 * 0:INDIVIDUALS: 0:usalu,1:mrdoob,2:nortikin,3:hannobraun,4:ricosjp
 * 1:COLLECTIVE: 0:ifcopenshell,1:cadquery,2:freecad,3:openscad,4:jscad
 * 2:NONPROFIT: 0:buildingsmart,1:nrel
 * 3:COMPANY: 0:mcneel,1:autodesk,2:nemetschek,3:esri,4:microsoft, 500:speckle,501:hypar
 *
 * @generated from protobuf enum semio.model.v1.Platform
 */
export enum Platform {
    /**
     * https://github.com/usalu/semio
     *
     * @generated from protobuf enum value: PLATFORM_SEMIO = 0;
     */
    SEMIO = 0,
    /**
     * https://github.com/specklesystems
     *
     * @generated from protobuf enum value: PLATFORM_SPECKLE = 1600350000;
     */
    SPECKLE = 1600350000,
    /**
     * https://github.com/mrdoob/three.js/
     *
     * @generated from protobuf enum value: PLATFORM_THREE = 1000000100;
     */
    THREE = 1000000100,
    /**
     * https://github.com/nortikin/sverchok
     *
     * @generated from protobuf enum value: PLATFORM_SVERCHOK = 500000200;
     */
    SVERCHOK = 500000200,
    /**
     * https://github.com/IfcOpenShell
     *
     * @generated from protobuf enum value: PLATFORM_IFCOPENSHELL = 1010100000;
     */
    IFCOPENSHELL = 1010100000,
    /**
     * https://github.com/CadQuery
     *
     * @generated from protobuf enum value: PLATFORM_CADQUERY = 1600100100;
     */
    CADQUERY = 1600100100,
    /**
     * https://github.com/FreeCAD
     *
     * @generated from protobuf enum value: PLATFORM_FREECAD = 530100200;
     */
    FREECAD = 530100200,
    /**
     * https://github.com/openscad
     *
     * @generated from protobuf enum value: PLATFORM_OPENSCAD = 530100300;
     */
    OPENSCAD = 530100300,
    /**
     * https://github.com/jscad
     *
     * @generated from protobuf enum value: PLATFORM_JSCAD = 1500100400;
     */
    JSCAD = 1500100400,
    /**
     * https://github.com/hannobraun/Fornjot
     *
     * @generated from protobuf enum value: PLATFORM_FORNJOT = 1700000300;
     */
    FORNJOT = 1700000300,
    /**
     * https://github.com/ricosjp/truck
     *
     * @generated from protobuf enum value: PLATFORM_TRUCK = 1500000400;
     */
    TRUCK = 1500000400,
    /**
     * https://github.com/NREL/EnergyPlus
     *
     * @generated from protobuf enum value: PLATFORM_ENERGYPLUS = 1900200100;
     */
    ENERGYPLUS = 1900200100,
    /**
     * https://github.com/NREL/OpenStudio
     *
     * @generated from protobuf enum value: PLATFORM_OPENSTUDIO = 1910200101;
     */
    OPENSTUDIO = 1910200101,
    /**
     * https://www.rhino3d.com/
     *
     * @generated from protobuf enum value: PLATFORM_RHINO = 2140300000;
     */
    RHINO = 2140300000,
    /**
     * https://www.grasshopper3d.com/
     *
     * @generated from protobuf enum value: PLATFORM_GRASSHOPPER = 2140300001;
     */
    GRASSHOPPER = 2140300001,
    /**
     * https://www.autodesk.de/products/revit/
     *
     * @generated from protobuf enum value: PLATFORM_REVIT = 2140300100;
     */
    REVIT = 2140300100,
    /**
     * https://dynamobim.org/
     *
     * @generated from protobuf enum value: PLATFORM_DYNAMO = 2140300101;
     */
    DYNAMO = 2140300101,
    /**
     * https://graphisoft.com/solutions/archicad
     *
     * @generated from protobuf enum value: PLATFORM_ARCHICAD = 2140300200;
     */
    ARCHICAD = 2140300200,
    /**
     * https://www.esri.com/en-us/arcgis/products/arcgis-cityengine
     *
     * @generated from protobuf enum value: PLATFORM_CITYENGINE = 2140300300;
     */
    CITYENGINE = 2140300300,
    /**
     * https://www.microsoft.com/en-us/microsoft-365/excel
     *
     * @generated from protobuf enum value: PLATFORM_EXCEL = 2140300400;
     */
    EXCEL = 2140300400,
    /**
     * https://hypar.io/
     *
     * @generated from protobuf enum value: PLATFORM_HYPAR = 2140350100;
     */
    HYPAR = 2140350100
}
/**
 * The representation protocol determines what type of representation the connecting will see of the connected in the connection process.
 *
 * @generated from protobuf enum semio.model.v1.RepresentationProtocol
 */
export enum RepresentationProtocol {
    /**
     * The connecting sees no representation of the connected.
     *
     * @generated from protobuf enum value: REPRESENTATIONPROTOCOL_NONE = 0;
     */
    REPRESENTATIONPROTOCOL_NONE = 0,
    /**
     * In the simple representation protocol everything is represented by a point.
     *
     * @generated from protobuf enum value: REPRESENTATIONPROTOCOL_SIMPLE = 1;
     */
    REPRESENTATIONPROTOCOL_SIMPLE = 1,
    /**
     * In the full representation protocol everything is represented by its native form where all information is available. This will most likely lead to strong coupled elements. Only use when absolutely necessary.
     *
     * @generated from protobuf enum value: REPRESENTATIONPROTOCOL_FULL = 2;
     */
    REPRESENTATIONPROTOCOL_FULL = 2
}
/**
 * A layout strategy affects in which orders connections are triggered.
 *
 * @generated from protobuf enum semio.model.v1.LayoutStrategy
 */
export enum LayoutStrategy {
    /**
     * A breadth first layout strategy will connect all neighbours first before these start to do the same with their neighbours.
     *
     * @generated from protobuf enum value: LAYOUTSTRATEGY_BREADTHFIRST = 0;
     */
    LAYOUTSTRATEGY_BREADTHFIRST = 0,
    /**
     * A depth first layout strategy will always prioritize to choose the neighbour of the neighbour first before the other neighbours of the root.
     *
     * @generated from protobuf enum value: LAYOUTSTRATEGY_DEPTHFIRST = 1;
     */
    LAYOUTSTRATEGY_DEPTHFIRST = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class Pose$Type extends MessageType<Pose> {
    constructor() {
        super("semio.model.v1.Pose", [
            { no: 1, name: "point_of_view", kind: "message", T: () => Point },
            { no: 2, name: "view", kind: "message", T: () => Quaternion }
        ]);
    }
    create(value?: PartialMessage<Pose>): Pose {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Pose>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Pose): Pose {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* semio.geometry.v1.Point point_of_view */ 1:
                    message.pointOfView = Point.internalBinaryRead(reader, reader.uint32(), options, message.pointOfView);
                    break;
                case /* semio.geometry.v1.Quaternion view */ 2:
                    message.view = Quaternion.internalBinaryRead(reader, reader.uint32(), options, message.view);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Pose, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* semio.geometry.v1.Point point_of_view = 1; */
        if (message.pointOfView)
            Point.internalBinaryWrite(message.pointOfView, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* semio.geometry.v1.Quaternion view = 2; */
        if (message.view)
            Quaternion.internalBinaryWrite(message.view, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Pose
 */
export const Pose = new Pose$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Representation$Type extends MessageType<Representation> {
    constructor() {
        super("semio.model.v1.Representation", [
            { no: 1, name: "body", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "encoding", kind: "enum", T: () => ["semio.model.v1.Encoding", Encoding, "ENCODING_"] },
            { no: 3, name: "file_type", kind: "enum", T: () => ["semio.model.v1.FileType", FileType] },
            { no: 4, name: "platform", kind: "enum", T: () => ["semio.model.v1.Platform", Platform, "PLATFORM_"] },
            { no: 5, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "concepts", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "lod", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Representation>): Representation {
        const message = { body: new Uint8Array(0), encoding: 0, fileType: 0, platform: 0, description: "", concepts: [], lod: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Representation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Representation): Representation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes body */ 1:
                    message.body = reader.bytes();
                    break;
                case /* semio.model.v1.Encoding encoding */ 2:
                    message.encoding = reader.int32();
                    break;
                case /* semio.model.v1.FileType file_type */ 3:
                    message.fileType = reader.int32();
                    break;
                case /* semio.model.v1.Platform platform */ 4:
                    message.platform = reader.int32();
                    break;
                case /* string description */ 5:
                    message.description = reader.string();
                    break;
                case /* repeated string concepts */ 6:
                    message.concepts.push(reader.string());
                    break;
                case /* int32 lod */ 7:
                    message.lod = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Representation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes body = 1; */
        if (message.body.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.body);
        /* semio.model.v1.Encoding encoding = 2; */
        if (message.encoding !== 0)
            writer.tag(2, WireType.Varint).int32(message.encoding);
        /* semio.model.v1.FileType file_type = 3; */
        if (message.fileType !== 0)
            writer.tag(3, WireType.Varint).int32(message.fileType);
        /* semio.model.v1.Platform platform = 4; */
        if (message.platform !== 0)
            writer.tag(4, WireType.Varint).int32(message.platform);
        /* string description = 5; */
        if (message.description !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.description);
        /* repeated string concepts = 6; */
        for (let i = 0; i < message.concepts.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.concepts[i]);
        /* int32 lod = 7; */
        if (message.lod !== 0)
            writer.tag(7, WireType.Varint).int32(message.lod);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Representation
 */
export const Representation = new Representation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Scope$Type extends MessageType<Scope> {
    constructor() {
        super("semio.model.v1.Scope", [
            { no: 1, name: "concept", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Scope>): Scope {
        const message = { concept: "", order: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Scope>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Scope): Scope {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string concept */ 1:
                    message.concept = reader.string();
                    break;
                case /* int32 order */ 2:
                    message.order = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Scope, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string concept = 1; */
        if (message.concept !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.concept);
        /* int32 order = 2; */
        if (message.order !== 0)
            writer.tag(2, WireType.Varint).int32(message.order);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Scope
 */
export const Scope = new Scope$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Value$Type extends MessageType<Value> {
    constructor() {
        super("semio.model.v1.Value", [
            { no: 1, name: "text", kind: "scalar", oneof: "value", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "number", kind: "scalar", oneof: "value", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "integer_number", kind: "scalar", oneof: "value", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "natural_number", kind: "scalar", oneof: "value", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "point", kind: "message", oneof: "value", T: () => Point }
        ]);
    }
    create(value?: PartialMessage<Value>): Value {
        const message = { value: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Value>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Value): Value {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.value = {
                        oneofKind: "text",
                        text: reader.string()
                    };
                    break;
                case /* double number */ 2:
                    message.value = {
                        oneofKind: "number",
                        number: reader.double()
                    };
                    break;
                case /* int32 integer_number */ 3:
                    message.value = {
                        oneofKind: "integerNumber",
                        integerNumber: reader.int32()
                    };
                    break;
                case /* uint32 natural_number */ 4:
                    message.value = {
                        oneofKind: "naturalNumber",
                        naturalNumber: reader.uint32()
                    };
                    break;
                case /* semio.geometry.v1.Point point */ 5:
                    message.value = {
                        oneofKind: "point",
                        point: Point.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).point)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Value, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.value.oneofKind === "text")
            writer.tag(1, WireType.LengthDelimited).string(message.value.text);
        /* double number = 2; */
        if (message.value.oneofKind === "number")
            writer.tag(2, WireType.Bit64).double(message.value.number);
        /* int32 integer_number = 3; */
        if (message.value.oneofKind === "integerNumber")
            writer.tag(3, WireType.Varint).int32(message.value.integerNumber);
        /* uint32 natural_number = 4; */
        if (message.value.oneofKind === "naturalNumber")
            writer.tag(4, WireType.Varint).uint32(message.value.naturalNumber);
        /* semio.geometry.v1.Point point = 5; */
        if (message.value.oneofKind === "point")
            Point.internalBinaryWrite(message.value.point, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Value
 */
export const Value = new Value$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Parameter$Type extends MessageType<Parameter> {
    constructor() {
        super("semio.model.v1.Parameter", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "context", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Scope },
            { no: 3, name: "value", kind: "message", T: () => Value }
        ]);
    }
    create(value?: PartialMessage<Parameter>): Parameter {
        const message = { name: "", context: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Parameter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Parameter): Parameter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated semio.model.v1.Scope context */ 2:
                    message.context.push(Scope.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* semio.model.v1.Value value */ 3:
                    message.value = Value.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Parameter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated semio.model.v1.Scope context = 2; */
        for (let i = 0; i < message.context.length; i++)
            Scope.internalBinaryWrite(message.context[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* semio.model.v1.Value value = 3; */
        if (message.value)
            Value.internalBinaryWrite(message.value, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Parameter
 */
export const Parameter = new Parameter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Plan$Type extends MessageType<Plan> {
    constructor() {
        super("semio.model.v1.Plan", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "parameters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Parameter }
        ]);
    }
    create(value?: PartialMessage<Plan>): Plan {
        const message = { url: "", parameters: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Plan>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Plan): Plan {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* repeated semio.model.v1.Parameter parameters */ 2:
                    message.parameters.push(Parameter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Plan, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* repeated semio.model.v1.Parameter parameters = 2; */
        for (let i = 0; i < message.parameters.length; i++)
            Parameter.internalBinaryWrite(message.parameters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Plan
 */
export const Plan = new Plan$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Sobject$Type extends MessageType<Sobject> {
    constructor() {
        super("semio.model.v1.Sobject", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pose", kind: "message", T: () => Pose },
            { no: 3, name: "plan", kind: "message", T: () => Plan },
            { no: 4, name: "concepts", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Sobject>): Sobject {
        const message = { id: "", concepts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Sobject>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Sobject): Sobject {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* semio.model.v1.Pose pose */ 2:
                    message.pose = Pose.internalBinaryRead(reader, reader.uint32(), options, message.pose);
                    break;
                case /* semio.model.v1.Plan plan */ 3:
                    message.plan = Plan.internalBinaryRead(reader, reader.uint32(), options, message.plan);
                    break;
                case /* repeated string concepts */ 4:
                    message.concepts.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Sobject, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* semio.model.v1.Pose pose = 2; */
        if (message.pose)
            Pose.internalBinaryWrite(message.pose, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* semio.model.v1.Plan plan = 3; */
        if (message.plan)
            Plan.internalBinaryWrite(message.plan, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string concepts = 4; */
        for (let i = 0; i < message.concepts.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.concepts[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Sobject
 */
export const Sobject = new Sobject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Link$Type extends MessageType<Link> {
    constructor() {
        super("semio.model.v1.Link", [
            { no: 1, name: "representationProtocol", kind: "enum", T: () => ["semio.model.v1.RepresentationProtocol", RepresentationProtocol] },
            { no: 2, name: "ports", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "bias_parameters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Parameter }
        ]);
    }
    create(value?: PartialMessage<Link>): Link {
        const message = { representationProtocol: 0, ports: [], biasParameters: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Link>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Link): Link {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* semio.model.v1.RepresentationProtocol representationProtocol */ 1:
                    message.representationProtocol = reader.int32();
                    break;
                case /* repeated string ports */ 2:
                    message.ports.push(reader.string());
                    break;
                case /* repeated semio.model.v1.Parameter bias_parameters */ 3:
                    message.biasParameters.push(Parameter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Link, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* semio.model.v1.RepresentationProtocol representationProtocol = 1; */
        if (message.representationProtocol !== 0)
            writer.tag(1, WireType.Varint).int32(message.representationProtocol);
        /* repeated string ports = 2; */
        for (let i = 0; i < message.ports.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.ports[i]);
        /* repeated semio.model.v1.Parameter bias_parameters = 3; */
        for (let i = 0; i < message.biasParameters.length; i++)
            Parameter.internalBinaryWrite(message.biasParameters[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Link
 */
export const Link = new Link$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Connectable$Type extends MessageType<Connectable> {
    constructor() {
        super("semio.model.v1.Connectable", [
            { no: 1, name: "sobject_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "link", kind: "message", T: () => Link }
        ]);
    }
    create(value?: PartialMessage<Connectable>): Connectable {
        const message = { sobjectId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Connectable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Connectable): Connectable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sobject_id */ 1:
                    message.sobjectId = reader.string();
                    break;
                case /* semio.model.v1.Link link */ 2:
                    message.link = Link.internalBinaryRead(reader, reader.uint32(), options, message.link);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Connectable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sobject_id = 1; */
        if (message.sobjectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sobjectId);
        /* semio.model.v1.Link link = 2; */
        if (message.link)
            Link.internalBinaryWrite(message.link, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Connectable
 */
export const Connectable = new Connectable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Connection$Type extends MessageType<Connection> {
    constructor() {
        super("semio.model.v1.Connection", [
            { no: 1, name: "connecting", kind: "message", T: () => Connectable },
            { no: 2, name: "connected", kind: "message", T: () => Connectable }
        ]);
    }
    create(value?: PartialMessage<Connection>): Connection {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Connection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Connection): Connection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* semio.model.v1.Connectable connecting */ 1:
                    message.connecting = Connectable.internalBinaryRead(reader, reader.uint32(), options, message.connecting);
                    break;
                case /* semio.model.v1.Connectable connected */ 2:
                    message.connected = Connectable.internalBinaryRead(reader, reader.uint32(), options, message.connected);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Connection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* semio.model.v1.Connectable connecting = 1; */
        if (message.connecting)
            Connectable.internalBinaryWrite(message.connecting, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* semio.model.v1.Connectable connected = 2; */
        if (message.connected)
            Connectable.internalBinaryWrite(message.connected, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Connection
 */
export const Connection = new Connection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Assembly$Type extends MessageType<Assembly> {
    constructor() {
        super("semio.model.v1.Assembly", [
            { no: 1, name: "sobject_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "parts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Assembly }
        ]);
    }
    create(value?: PartialMessage<Assembly>): Assembly {
        const message = { sobjectId: "", parts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Assembly>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Assembly): Assembly {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sobject_id */ 1:
                    message.sobjectId = reader.string();
                    break;
                case /* repeated semio.model.v1.Assembly parts */ 2:
                    message.parts.push(Assembly.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Assembly, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sobject_id = 1; */
        if (message.sobjectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sobjectId);
        /* repeated semio.model.v1.Assembly parts = 2; */
        for (let i = 0; i < message.parts.length; i++)
            Assembly.internalBinaryWrite(message.parts[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Assembly
 */
export const Assembly = new Assembly$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Layout$Type extends MessageType<Layout> {
    constructor() {
        super("semio.model.v1.Layout", [
            { no: 1, name: "sobjects", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Sobject },
            { no: 2, name: "connections", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Connection },
            { no: 3, name: "strategy", kind: "enum", T: () => ["semio.model.v1.LayoutStrategy", LayoutStrategy] },
            { no: 4, name: "assemblies", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Assembly }
        ]);
    }
    create(value?: PartialMessage<Layout>): Layout {
        const message = { sobjects: [], connections: [], strategy: 0, assemblies: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Layout>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Layout): Layout {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated semio.model.v1.Sobject sobjects */ 1:
                    message.sobjects.push(Sobject.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated semio.model.v1.Connection connections */ 2:
                    message.connections.push(Connection.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* semio.model.v1.LayoutStrategy strategy */ 3:
                    message.strategy = reader.int32();
                    break;
                case /* repeated semio.model.v1.Assembly assemblies */ 4:
                    message.assemblies.push(Assembly.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Layout, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated semio.model.v1.Sobject sobjects = 1; */
        for (let i = 0; i < message.sobjects.length; i++)
            Sobject.internalBinaryWrite(message.sobjects[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated semio.model.v1.Connection connections = 2; */
        for (let i = 0; i < message.connections.length; i++)
            Connection.internalBinaryWrite(message.connections[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* semio.model.v1.LayoutStrategy strategy = 3; */
        if (message.strategy !== 0)
            writer.tag(3, WireType.Varint).int32(message.strategy);
        /* repeated semio.model.v1.Assembly assemblies = 4; */
        for (let i = 0; i < message.assemblies.length; i++)
            Assembly.internalBinaryWrite(message.assemblies[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Layout
 */
export const Layout = new Layout$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Prototype$Type extends MessageType<Prototype> {
    constructor() {
        super("semio.model.v1.Prototype", [
            { no: 1, name: "plan_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "representations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Representation },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Prototype>): Prototype {
        const message = { planHash: "", representations: [], description: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Prototype>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Prototype): Prototype {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string plan_hash */ 1:
                    message.planHash = reader.string();
                    break;
                case /* repeated semio.model.v1.Representation representations */ 2:
                    message.representations.push(Representation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Prototype, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string plan_hash = 1; */
        if (message.planHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.planHash);
        /* repeated semio.model.v1.Representation representations = 2; */
        for (let i = 0; i < message.representations.length; i++)
            Representation.internalBinaryWrite(message.representations[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Prototype
 */
export const Prototype = new Prototype$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Element$Type extends MessageType<Element> {
    constructor() {
        super("semio.model.v1.Element", [
            { no: 1, name: "sobject_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "prototype_plan_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pose", kind: "message", T: () => Pose }
        ]);
    }
    create(value?: PartialMessage<Element>): Element {
        const message = { sobjectId: "", prototypePlanHash: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Element>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Element): Element {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sobject_id */ 1:
                    message.sobjectId = reader.string();
                    break;
                case /* string prototype_plan_hash */ 2:
                    message.prototypePlanHash = reader.string();
                    break;
                case /* semio.model.v1.Pose pose */ 3:
                    message.pose = Pose.internalBinaryRead(reader, reader.uint32(), options, message.pose);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Element, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sobject_id = 1; */
        if (message.sobjectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sobjectId);
        /* string prototype_plan_hash = 2; */
        if (message.prototypePlanHash !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.prototypePlanHash);
        /* semio.model.v1.Pose pose = 3; */
        if (message.pose)
            Pose.internalBinaryWrite(message.pose, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Element
 */
export const Element = new Element$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Design$Type extends MessageType<Design> {
    constructor() {
        super("semio.model.v1.Design", [
            { no: 1, name: "prototypes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Prototype },
            { no: 2, name: "elements", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Element }
        ]);
    }
    create(value?: PartialMessage<Design>): Design {
        const message = { prototypes: [], elements: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Design>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Design): Design {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated semio.model.v1.Prototype prototypes */ 1:
                    message.prototypes.push(Prototype.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated semio.model.v1.Element elements */ 2:
                    message.elements.push(Element.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Design, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated semio.model.v1.Prototype prototypes = 1; */
        for (let i = 0; i < message.prototypes.length; i++)
            Prototype.internalBinaryWrite(message.prototypes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated semio.model.v1.Element elements = 2; */
        for (let i = 0; i < message.elements.length; i++)
            Element.internalBinaryWrite(message.elements[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Design
 */
export const Design = new Design$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayoutModification$Type extends MessageType<LayoutModification> {
    constructor() {
        super("semio.model.v1.LayoutModification", [
            { no: 1, name: "context", kind: "message", T: () => Layout },
            { no: 2, name: "modified_context", kind: "message", T: () => Layout }
        ]);
    }
    create(value?: PartialMessage<LayoutModification>): LayoutModification {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LayoutModification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayoutModification): LayoutModification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* semio.model.v1.Layout context */ 1:
                    message.context = Layout.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* semio.model.v1.Layout modified_context */ 2:
                    message.modifiedContext = Layout.internalBinaryRead(reader, reader.uint32(), options, message.modifiedContext);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LayoutModification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* semio.model.v1.Layout context = 1; */
        if (message.context)
            Layout.internalBinaryWrite(message.context, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* semio.model.v1.Layout modified_context = 2; */
        if (message.modifiedContext)
            Layout.internalBinaryWrite(message.modifiedContext, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.LayoutModification
 */
export const LayoutModification = new LayoutModification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayoutModificationStrategy$Type extends MessageType<LayoutModificationStrategy> {
    constructor() {
        super("semio.model.v1.LayoutModificationStrategy", [
            { no: 1, name: "match_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LayoutModificationStrategy>): LayoutModificationStrategy {
        const message = { matchCount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LayoutModificationStrategy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayoutModificationStrategy): LayoutModificationStrategy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 match_count */ 1:
                    message.matchCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LayoutModificationStrategy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 match_count = 1; */
        if (message.matchCount !== 0)
            writer.tag(1, WireType.Varint).uint32(message.matchCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.LayoutModificationStrategy
 */
export const LayoutModificationStrategy = new LayoutModificationStrategy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Decision$Type extends MessageType<Decision> {
    constructor() {
        super("semio.model.v1.Decision", [
            { no: 1, name: "modification", kind: "message", T: () => LayoutModification },
            { no: 2, name: "strategy", kind: "message", T: () => LayoutModificationStrategy }
        ]);
    }
    create(value?: PartialMessage<Decision>): Decision {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Decision>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Decision): Decision {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* semio.model.v1.LayoutModification modification */ 1:
                    message.modification = LayoutModification.internalBinaryRead(reader, reader.uint32(), options, message.modification);
                    break;
                case /* semio.model.v1.LayoutModificationStrategy strategy */ 2:
                    message.strategy = LayoutModificationStrategy.internalBinaryRead(reader, reader.uint32(), options, message.strategy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Decision, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* semio.model.v1.LayoutModification modification = 1; */
        if (message.modification)
            LayoutModification.internalBinaryWrite(message.modification, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* semio.model.v1.LayoutModificationStrategy strategy = 2; */
        if (message.strategy)
            LayoutModificationStrategy.internalBinaryWrite(message.strategy, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Decision
 */
export const Decision = new Decision$Type();
