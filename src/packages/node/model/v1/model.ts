// @generated by protobuf-ts 2.8.2 with parameter server_grpc1,generate_dependencies
// @generated from protobuf file "model/v1/model.proto" (package "semio.model.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * A 3d point with x,y,z coordinates.
 *
 * @generated from protobuf message semio.model.v1.Point
 */
export interface Point {
    /**
     * x coordinate.
     *
     * @generated from protobuf field: double x = 1;
     */
    x: number;
    /**
     * y coordinate
     *
     * @generated from protobuf field: double y = 2;
     */
    y: number;
    /**
     * z coordinate
     *
     * @generated from protobuf field: double z = 3;
     */
    z: number;
}
/**
 * Quaternions represent (here) (rotational) orientation. It can be interpreted as the view of an element.
 *
 * @generated from protobuf message semio.model.v1.Quaternion
 */
export interface Quaternion {
    /**
     * @generated from protobuf field: double w = 1;
     */
    w: number;
    /**
     * @generated from protobuf field: double x = 2;
     */
    x: number;
    /**
     * @generated from protobuf field: double y = 3;
     */
    y: number;
    /**
     * @generated from protobuf field: double z = 4;
     */
    z: number;
}
/**
 * A pose is a reference frame with a point of view (origin) and orientation (view).
 *
 * @generated from protobuf message semio.model.v1.Pose
 */
export interface Pose {
    /**
     * @generated from protobuf field: semio.model.v1.Point point_of_view = 1;
     */
    pointOfView?: Point;
    /**
     * @generated from protobuf field: semio.model.v1.Quaternion view = 2;
     */
    view?: Quaternion;
}
/**
 * A representation for an element. Basically a file with some semio specific metadata.
 *
 * @generated from protobuf message semio.model.v1.Representation
 */
export interface Representation {
    /**
     * The body depends on the serialization format of the representation.
     *
     * @generated from protobuf field: bytes body = 1;
     */
    body: Uint8Array;
    /**
     * Encoding of the body
     *
     * @generated from protobuf field: semio.model.v1.Encoding encoding = 2;
     */
    encoding: Encoding;
    /**
     * Use the abbreviation of the platform. You can find that in the constants part of the package.
     *
     * @generated from protobuf field: semio.model.v1.FileType file_type = 3;
     */
    fileType: FileType;
    /**
     * Native platform of representation
     *
     * @generated from protobuf field: semio.model.v1.Platform platform = 4;
     */
    platform: Platform;
    /**
     * A description of the representation for humans to understand what the purpose of this representation is.
     *
     * @generated from protobuf field: string description = 5;
     */
    description: string;
    /**
     * Add a list of concepts that help filtering representations. This can be used for functional purpose (e.g. statical, energetical, ...) or for visualization purpose (e.g. volumetric,comic, , ...).
     *
     * @generated from protobuf field: repeated string concepts = 6;
     */
    concepts: string[];
    /**
     * Level of detail allows to further define representation details. Like name this can be used either for visualization purpose (e.g. 200 (scale 1to200)) or functional purpose (e.g level of structural detail)
     * For architectural design it is recommended to choose the scale multiplier.
     * For BIM you might want to choose:
     * 100:Conceptual
     * 200:Approximate
     * 300:Precise
     * 400:Fabriaction
     * 500:Real
     *
     * @generated from protobuf field: int64 lod = 7;
     */
    lod: bigint;
}
/**
 * Instance information for an element.
 *
 * @generated from protobuf message semio.model.v1.Sobject
 */
export interface Sobject {
    /**
     * Id that allows to distinguish it from other sobjects.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * The url of the element definition.
     *
     * @generated from protobuf field: string url = 2;
     */
    url: string;
    /**
     * Parameters for the element.
     *
     * @generated from protobuf field: map<string, string> parameters = 3;
     */
    parameters: {
        [key: string]: string;
    };
}
/**
 * An attraction participant participates in an attraction process.
 *
 * @generated from protobuf message semio.model.v1.AttractionParticipant
 */
export interface AttractionParticipant {
    /**
     * Id of participating sobject.
     *
     * @generated from protobuf field: string participant_id = 1;
     */
    participantId: string;
    /**
     * The (rough) pose of the participating sobject. Note that in the attraction process it will most likely be displaced and adjusted.
     *
     * @generated from protobuf field: semio.model.v1.Pose pose = 2;
     */
    pose?: Pose;
    /**
     * An optional representation of the participant.
     *
     * @generated from protobuf field: semio.model.v1.RepresentationProtocol representationProtocol = 3;
     */
    representationProtocol: RepresentationProtocol;
    /**
     * Optional port names to connect to. The hierarchy should matter
     *
     * @generated from protobuf field: repeated string ports = 4;
     */
    ports: string[];
    /**
     * Optional parameters to bias the attraction.
     *
     * @generated from protobuf field: map<string, string> bias = 5;
     */
    bias: {
        [key: string]: string;
    };
}
/**
 * An attraction can be used to attract an attracted attraction participant to an attractor attraction participant.
 *
 * @generated from protobuf message semio.model.v1.Attraction
 */
export interface Attraction {
    /**
     * Id that allows to distinguish it from other attractions.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * The attractor is expected to be the fixed sobject.
     *
     * @generated from protobuf field: semio.model.v1.AttractionParticipant attractor = 2;
     */
    attractor?: AttractionParticipant;
    /**
     * The attracted is expected to be the flexible sobject that adjusts its point of view.
     *
     * @generated from protobuf field: semio.model.v1.AttractionParticipant attracted = 3;
     */
    attracted?: AttractionParticipant;
}
/**
 * An attraction tree defines a possibly unambiguous subset of a layout.
 *
 * @generated from protobuf message semio.model.v1.AttractionTree
 */
export interface AttractionTree {
    /**
     * The id of the sobject to place.
     *
     * @generated from protobuf field: string sobject_id = 1;
     */
    sobjectId: string;
    /**
     * An optional id of the attraction that is used to place this sobject. Only relevent when multiple attractions are defined from the same type.
     * Roots can't have that field as they have no parent.
     *
     * @generated from protobuf field: string attraction_id = 2;
     */
    attractionId: string;
    /**
     * @generated from protobuf field: repeated semio.model.v1.AttractionTree children = 3;
     */
    children: AttractionTree[];
}
/**
 * A layout (graph) is an assembly plan for a set of sobjects and their attractions between each other.
 *
 * @generated from protobuf message semio.model.v1.Layout
 */
export interface Layout {
    /**
     * Sobjects (nodes) that are part of the layout (graph).
     *
     * @generated from protobuf field: repeated semio.model.v1.Sobject sobjects = 1;
     */
    sobjects: Sobject[];
    /**
     * Attractions (edges) that are part of the layout (graph).
     *
     * @generated from protobuf field: repeated semio.model.v1.Attraction attractions = 2;
     */
    attractions: Attraction[];
    /**
     * @generated from protobuf field: semio.model.v1.LayoutStrategy strategy = 3;
     */
    strategy: LayoutStrategy;
    /**
     * Optional attraction trees that can possibly unambiguously describe the layout order of sobjects.
     * Most of the time this field is only necissary due to elements that don't work well together in a general way.
     * Therefore if you can update the element definitions to be more robust, rather use your time for that.
     *
     * @generated from protobuf field: repeated semio.model.v1.AttractionTree attraction_trees = 4;
     */
    attractionTrees: AttractionTree[];
}
/**
 * An element is the atom of a design. It has several representations and a pose.
 *
 * @generated from protobuf message semio.model.v1.Element
 */
export interface Element {
    /**
     * The id of the sobject that was used to create the element is also the element id.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: repeated semio.model.v1.Representation representations = 2;
     */
    representations: Representation[];
    /**
     * An optional human readable description of the element.
     *
     * @generated from protobuf field: string description = 3;
     */
    description: string;
}
/**
 * An element tree maps elements to poseses (one element can occur in several places) and their relationship between each other (part-whole).
 *
 * @generated from protobuf message semio.model.v1.ElementTree
 */
export interface ElementTree {
    /**
     * An optional element id
     *
     * @generated from protobuf field: string element_id = 1;
     */
    elementId: string;
    /**
     * An optional pose of the element tree.
     *
     * @generated from protobuf field: semio.model.v1.Pose pose = 2;
     */
    pose?: Pose;
    /**
     * An optional url of a type for the concept tree.
     *
     * @generated from protobuf field: string type = 3;
     */
    type: string;
    /**
     * All parts (element trees) with the main concepts as keys and the subconcepts trees as values.
     *
     * @generated from protobuf field: map<string, semio.model.v1.ElementTree> parts = 4;
     */
    parts: {
        [key: string]: ElementTree;
    };
}
/**
 * A design is an aggregation of elements.
 *
 * @generated from protobuf message semio.model.v1.Design
 */
export interface Design {
    /**
     * @generated from protobuf field: repeated semio.model.v1.Element elements = 1;
     */
    elements: Element[];
    /**
     * @generated from protobuf field: repeated semio.model.v1.ElementTree elementTrees = 2;
     */
    elementTrees: ElementTree[];
}
/**
 * A layout modification describes declaratively a layout and the layout after its modification. The rules on how to imperatively change such a layout need to be found by the transformation system.
 *
 * @generated from protobuf message semio.model.v1.LayoutModification
 */
export interface LayoutModification {
    /**
     * @generated from protobuf field: semio.model.v1.Layout context = 1;
     */
    context?: Layout;
    /**
     * @generated from protobuf field: semio.model.v1.Layout modified_context = 2;
     */
    modifiedContext?: Layout;
}
/**
 * A decision strategy holds information on how modifications are applied.
 *
 * @generated from protobuf message semio.model.v1.LayoutModificationStrategy
 */
export interface LayoutModificationStrategy {
    /**
     * The match count describes how often a layout modification should be applied. It beeing finite will make sure that the system always terminates. Make sure to set the threshold high enough.
     *
     * @generated from protobuf field: int64 match_count = 1;
     */
    matchCount: bigint;
}
/**
 * A decision is a layout modification with a strategy on how to apply it to a new layout.
 *
 * @generated from protobuf message semio.model.v1.Decision
 */
export interface Decision {
    /**
     * @generated from protobuf field: semio.model.v1.LayoutModification modification = 1;
     */
    modification?: LayoutModification;
    /**
     * @generated from protobuf field: semio.model.v1.LayoutModificationStrategy strategy = 2;
     */
    strategy?: LayoutModificationStrategy;
}
/**
 * Encoding of a byte array.
 *
 * @generated from protobuf enum semio.model.v1.Encoding
 */
export enum Encoding {
    /**
     * @generated from protobuf enum value: ENCODING_TEXT_UFT8 = 0;
     */
    TEXT_UFT8 = 0,
    /**
     * @generated from protobuf enum value: ENCODING_TEXT_UFT16 = 1;
     */
    TEXT_UFT16 = 1,
    /**
     * @generated from protobuf enum value: ENCODING_TEXT_UFT32 = 2;
     */
    TEXT_UFT32 = 2,
    /**
     * @generated from protobuf enum value: ENCODING_TEXT_ASCII = 3;
     */
    TEXT_ASCII = 3,
    /**
     * Also ASCII but with further base 64 encoding of the text.
     *
     * @generated from protobuf enum value: ENCODING_TEXT_BASE64 = 4;
     */
    TEXT_BASE64 = 4
}
/**
 * @generated from protobuf enum semio.model.v1.FileType
 */
export enum FileType {
    /**
     * Native serialization according platform. Use this only when it is none of the others.
     * Often files have a platform specific extension but if you open them in a text editor you can see that they are serialized in a standard format.
     *
     * @generated from protobuf enum value: FILETYPE_NATIVE = 0;
     */
    FILETYPE_NATIVE = 0,
    /**
     * @generated from protobuf enum value: FILETYPE_JSON = 1;
     */
    FILETYPE_JSON = 1,
    /**
     * @generated from protobuf enum value: FILETYPE_XML = 2;
     */
    FILETYPE_XML = 2,
    /**
     * @generated from protobuf enum value: FILETYPE_YAML = 3;
     */
    FILETYPE_YAML = 3,
    /**
     * @generated from protobuf enum value: FILETYPE_TOML = 4;
     */
    FILETYPE_TOML = 4,
    /**
     * https://www.iso.org/standard/63141.html
     *
     * @generated from protobuf enum value: FILETYPE_STEP = 5;
     */
    FILETYPE_STEP = 5,
    /**
     * Python
     *
     * @generated from protobuf enum value: FILETYPE_PY = 6;
     */
    FILETYPE_PY = 6,
    /**
     * @generated from protobuf enum value: FILETYPE_C = 7;
     */
    FILETYPE_C = 7,
    /**
     * C++
     *
     * @generated from protobuf enum value: FILETYPE_CPP = 8;
     */
    FILETYPE_CPP = 8,
    /**
     * C#
     *
     * @generated from protobuf enum value: FILETYPE_CSHARP = 9;
     */
    FILETYPE_CSHARP = 9,
    /**
     * Golang
     *
     * @generated from protobuf enum value: FILETYPE_GO = 10;
     */
    FILETYPE_GO = 10,
    /**
     * @generated from protobuf enum value: FILETYPE_RUST = 11;
     */
    FILETYPE_RUST = 11
}
/**
 * Platform. Constants are encoded with pattern LICENSE [3] + OWNERTYPE [2] + OWNERID [3] + PLATFORMID [2]
 * LICENSE after https://spdx.org/licenses/:
 * 0:AGPL-3.0-or-later,
 * 50:GPL-3.0+,51:GPL-3.0,52:GPL-2.0+,53:GPL-2.0
 * 100:LGPL-3.0-or-later,101:LGPL-3.0-only
 * 150:MIT,160:Apache-2.0,170:0BSD
 * 214:Closed
 * OWNER starting with OWNERTYPE:
 * 0:INDIVIDUALS: 0:usalu,1:mrdoob,2:nortikin,3:hannobraun,4:ricosjp
 * 1:COLLECTIVE: 0:ifcopenshell,1:cadquery,2:freecad,3:openscad,4:jscad
 * 2:NONPROFIT: 0:buildingsmart
 * 3:COMPANY: 0:mcneel,1:autodesk,2:nemetschek,3:esri
 *
 * @generated from protobuf enum semio.model.v1.Platform
 */
export enum Platform {
    /**
     * https://github.com/usalu/semio
     *
     * @generated from protobuf enum value: PLATFORM_SEMIO = 0;
     */
    SEMIO = 0,
    /**
     * https://github.com/mrdoob/three.js/
     *
     * @generated from protobuf enum value: PLATFORM_THREE = 1000000100;
     */
    THREE = 1000000100,
    /**
     * https://github.com/nortikin/sverchok
     *
     * @generated from protobuf enum value: PLATFORM_SVERCHOK = 500000200;
     */
    SVERCHOK = 500000200,
    /**
     * https://github.com/IfcOpenShell
     *
     * @generated from protobuf enum value: PLATFORM_IFCOPENSHELL = 1010100000;
     */
    IFCOPENSHELL = 1010100000,
    /**
     * https://github.com/CadQuery
     *
     * @generated from protobuf enum value: PLATFORM_CADQUERY = 1600100100;
     */
    CADQUERY = 1600100100,
    /**
     * https://github.com/FreeCAD
     *
     * @generated from protobuf enum value: PLATFORM_FREECAD = 530100200;
     */
    FREECAD = 530100200,
    /**
     * https://github.com/openscad
     *
     * @generated from protobuf enum value: PLATFORM_OPENSCAD = 530100300;
     */
    OPENSCAD = 530100300,
    /**
     * https://github.com/jscad
     *
     * @generated from protobuf enum value: PLATFORM_JSCAD = 1500100400;
     */
    JSCAD = 1500100400,
    /**
     * https://github.com/hannobraun/Fornjot
     *
     * @generated from protobuf enum value: PLATFORM_Fornjot = 1700000300;
     */
    Fornjot = 1700000300,
    /**
     * https://github.com/ricosjp/truck
     *
     * @generated from protobuf enum value: PLATFORM_TRUCK = 1500000400;
     */
    TRUCK = 1500000400,
    /**
     * https://www.rhino3d.com/
     *
     * @generated from protobuf enum value: PLATFORM_RHINO = 2140300000;
     */
    RHINO = 2140300000,
    /**
     * https://www.grasshopper3d.com/
     *
     * @generated from protobuf enum value: PLATFORM_GRASSHOPPER = 2140300001;
     */
    GRASSHOPPER = 2140300001,
    /**
     * https://www.autodesk.de/products/revit/
     *
     * @generated from protobuf enum value: PLATFORM_REVIT = 2140300100;
     */
    REVIT = 2140300100,
    /**
     * https://dynamobim.org/
     *
     * @generated from protobuf enum value: PLATFORM_DYNAMO = 2140300101;
     */
    DYNAMO = 2140300101
}
/**
 * The representation protocol determines what type of representation the attractor will see of the attracted in the attraction process.
 *
 * @generated from protobuf enum semio.model.v1.RepresentationProtocol
 */
export enum RepresentationProtocol {
    /**
     * The attractor sees no representation of the attracted.
     *
     * @generated from protobuf enum value: REPRESENTATIONPROTOCOL_NONE = 0;
     */
    REPRESENTATIONPROTOCOL_NONE = 0,
    /**
     * In the simple representation protocol everything is represented by a point.
     *
     * @generated from protobuf enum value: REPRESENTATIONPROTOCOL_SIMPLE = 1;
     */
    REPRESENTATIONPROTOCOL_SIMPLE = 1,
    /**
     * In the full representation protocol everything is represented by its native form where all information is available. This will most likely lead to strong coupled elements. Only use when absolutely necessary.
     *
     * @generated from protobuf enum value: REPRESENTATIONPROTOCOL_FULL = 2;
     */
    REPRESENTATIONPROTOCOL_FULL = 2
}
/**
 * A layout strategy affects in which orders attractions are triggered.
 *
 * @generated from protobuf enum semio.model.v1.LayoutStrategy
 */
export enum LayoutStrategy {
    /**
     * A breadth first layout strategy will attract all neighbours first before these start to do the same with their neighbours.
     *
     * @generated from protobuf enum value: LAYOUTSTRATEGY_BREADTHFIRST = 0;
     */
    LAYOUTSTRATEGY_BREADTHFIRST = 0,
    /**
     * A depth first layout strategy will always prioritize to choose the neighbour of the neighbour first before the other neighbours of the root.
     *
     * @generated from protobuf enum value: LAYOUTSTRATEGY_DEPTHFIRST = 1;
     */
    LAYOUTSTRATEGY_DEPTHFIRST = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class Point$Type extends MessageType<Point> {
    constructor() {
        super("semio.model.v1.Point", [
            { no: 1, name: "x", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "y", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "z", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Point>): Point {
        const message = { x: 0, y: 0, z: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Point>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Point): Point {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double x */ 1:
                    message.x = reader.double();
                    break;
                case /* double y */ 2:
                    message.y = reader.double();
                    break;
                case /* double z */ 3:
                    message.z = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Point, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit64).double(message.x);
        /* double y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit64).double(message.y);
        /* double z = 3; */
        if (message.z !== 0)
            writer.tag(3, WireType.Bit64).double(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Point
 */
export const Point = new Point$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Quaternion$Type extends MessageType<Quaternion> {
    constructor() {
        super("semio.model.v1.Quaternion", [
            { no: 1, name: "w", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "x", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "y", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "z", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Quaternion>): Quaternion {
        const message = { w: 0, x: 0, y: 0, z: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Quaternion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Quaternion): Quaternion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double w */ 1:
                    message.w = reader.double();
                    break;
                case /* double x */ 2:
                    message.x = reader.double();
                    break;
                case /* double y */ 3:
                    message.y = reader.double();
                    break;
                case /* double z */ 4:
                    message.z = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Quaternion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double w = 1; */
        if (message.w !== 0)
            writer.tag(1, WireType.Bit64).double(message.w);
        /* double x = 2; */
        if (message.x !== 0)
            writer.tag(2, WireType.Bit64).double(message.x);
        /* double y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Bit64).double(message.y);
        /* double z = 4; */
        if (message.z !== 0)
            writer.tag(4, WireType.Bit64).double(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Quaternion
 */
export const Quaternion = new Quaternion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Pose$Type extends MessageType<Pose> {
    constructor() {
        super("semio.model.v1.Pose", [
            { no: 1, name: "point_of_view", kind: "message", T: () => Point },
            { no: 2, name: "view", kind: "message", T: () => Quaternion }
        ]);
    }
    create(value?: PartialMessage<Pose>): Pose {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Pose>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Pose): Pose {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* semio.model.v1.Point point_of_view */ 1:
                    message.pointOfView = Point.internalBinaryRead(reader, reader.uint32(), options, message.pointOfView);
                    break;
                case /* semio.model.v1.Quaternion view */ 2:
                    message.view = Quaternion.internalBinaryRead(reader, reader.uint32(), options, message.view);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Pose, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* semio.model.v1.Point point_of_view = 1; */
        if (message.pointOfView)
            Point.internalBinaryWrite(message.pointOfView, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* semio.model.v1.Quaternion view = 2; */
        if (message.view)
            Quaternion.internalBinaryWrite(message.view, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Pose
 */
export const Pose = new Pose$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Representation$Type extends MessageType<Representation> {
    constructor() {
        super("semio.model.v1.Representation", [
            { no: 1, name: "body", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "encoding", kind: "enum", T: () => ["semio.model.v1.Encoding", Encoding, "ENCODING_"] },
            { no: 3, name: "file_type", kind: "enum", T: () => ["semio.model.v1.FileType", FileType] },
            { no: 4, name: "platform", kind: "enum", T: () => ["semio.model.v1.Platform", Platform, "PLATFORM_"] },
            { no: 5, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "concepts", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "lod", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Representation>): Representation {
        const message = { body: new Uint8Array(0), encoding: 0, fileType: 0, platform: 0, description: "", concepts: [], lod: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Representation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Representation): Representation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes body */ 1:
                    message.body = reader.bytes();
                    break;
                case /* semio.model.v1.Encoding encoding */ 2:
                    message.encoding = reader.int32();
                    break;
                case /* semio.model.v1.FileType file_type */ 3:
                    message.fileType = reader.int32();
                    break;
                case /* semio.model.v1.Platform platform */ 4:
                    message.platform = reader.int32();
                    break;
                case /* string description */ 5:
                    message.description = reader.string();
                    break;
                case /* repeated string concepts */ 6:
                    message.concepts.push(reader.string());
                    break;
                case /* int64 lod */ 7:
                    message.lod = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Representation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes body = 1; */
        if (message.body.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.body);
        /* semio.model.v1.Encoding encoding = 2; */
        if (message.encoding !== 0)
            writer.tag(2, WireType.Varint).int32(message.encoding);
        /* semio.model.v1.FileType file_type = 3; */
        if (message.fileType !== 0)
            writer.tag(3, WireType.Varint).int32(message.fileType);
        /* semio.model.v1.Platform platform = 4; */
        if (message.platform !== 0)
            writer.tag(4, WireType.Varint).int32(message.platform);
        /* string description = 5; */
        if (message.description !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.description);
        /* repeated string concepts = 6; */
        for (let i = 0; i < message.concepts.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.concepts[i]);
        /* int64 lod = 7; */
        if (message.lod !== 0n)
            writer.tag(7, WireType.Varint).int64(message.lod);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Representation
 */
export const Representation = new Representation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Sobject$Type extends MessageType<Sobject> {
    constructor() {
        super("semio.model.v1.Sobject", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "parameters", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<Sobject>): Sobject {
        const message = { id: "", url: "", parameters: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Sobject>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Sobject): Sobject {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                case /* map<string, string> parameters */ 3:
                    this.binaryReadMap3(message.parameters, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: Sobject["parameters"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Sobject["parameters"] | undefined, val: Sobject["parameters"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field semio.model.v1.Sobject.parameters");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Sobject, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        /* map<string, string> parameters = 3; */
        for (let k of Object.keys(message.parameters))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.parameters[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Sobject
 */
export const Sobject = new Sobject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttractionParticipant$Type extends MessageType<AttractionParticipant> {
    constructor() {
        super("semio.model.v1.AttractionParticipant", [
            { no: 1, name: "participant_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pose", kind: "message", T: () => Pose },
            { no: 3, name: "representationProtocol", kind: "enum", T: () => ["semio.model.v1.RepresentationProtocol", RepresentationProtocol] },
            { no: 4, name: "ports", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "bias", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<AttractionParticipant>): AttractionParticipant {
        const message = { participantId: "", representationProtocol: 0, ports: [], bias: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AttractionParticipant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttractionParticipant): AttractionParticipant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string participant_id */ 1:
                    message.participantId = reader.string();
                    break;
                case /* semio.model.v1.Pose pose */ 2:
                    message.pose = Pose.internalBinaryRead(reader, reader.uint32(), options, message.pose);
                    break;
                case /* semio.model.v1.RepresentationProtocol representationProtocol */ 3:
                    message.representationProtocol = reader.int32();
                    break;
                case /* repeated string ports */ 4:
                    message.ports.push(reader.string());
                    break;
                case /* map<string, string> bias */ 5:
                    this.binaryReadMap5(message.bias, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: AttractionParticipant["bias"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AttractionParticipant["bias"] | undefined, val: AttractionParticipant["bias"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field semio.model.v1.AttractionParticipant.bias");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AttractionParticipant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string participant_id = 1; */
        if (message.participantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.participantId);
        /* semio.model.v1.Pose pose = 2; */
        if (message.pose)
            Pose.internalBinaryWrite(message.pose, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* semio.model.v1.RepresentationProtocol representationProtocol = 3; */
        if (message.representationProtocol !== 0)
            writer.tag(3, WireType.Varint).int32(message.representationProtocol);
        /* repeated string ports = 4; */
        for (let i = 0; i < message.ports.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.ports[i]);
        /* map<string, string> bias = 5; */
        for (let k of Object.keys(message.bias))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.bias[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.AttractionParticipant
 */
export const AttractionParticipant = new AttractionParticipant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Attraction$Type extends MessageType<Attraction> {
    constructor() {
        super("semio.model.v1.Attraction", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "attractor", kind: "message", T: () => AttractionParticipant },
            { no: 3, name: "attracted", kind: "message", T: () => AttractionParticipant }
        ]);
    }
    create(value?: PartialMessage<Attraction>): Attraction {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Attraction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Attraction): Attraction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* semio.model.v1.AttractionParticipant attractor */ 2:
                    message.attractor = AttractionParticipant.internalBinaryRead(reader, reader.uint32(), options, message.attractor);
                    break;
                case /* semio.model.v1.AttractionParticipant attracted */ 3:
                    message.attracted = AttractionParticipant.internalBinaryRead(reader, reader.uint32(), options, message.attracted);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Attraction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* semio.model.v1.AttractionParticipant attractor = 2; */
        if (message.attractor)
            AttractionParticipant.internalBinaryWrite(message.attractor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* semio.model.v1.AttractionParticipant attracted = 3; */
        if (message.attracted)
            AttractionParticipant.internalBinaryWrite(message.attracted, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Attraction
 */
export const Attraction = new Attraction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttractionTree$Type extends MessageType<AttractionTree> {
    constructor() {
        super("semio.model.v1.AttractionTree", [
            { no: 1, name: "sobject_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "attraction_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "children", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AttractionTree }
        ]);
    }
    create(value?: PartialMessage<AttractionTree>): AttractionTree {
        const message = { sobjectId: "", attractionId: "", children: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AttractionTree>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttractionTree): AttractionTree {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sobject_id */ 1:
                    message.sobjectId = reader.string();
                    break;
                case /* string attraction_id */ 2:
                    message.attractionId = reader.string();
                    break;
                case /* repeated semio.model.v1.AttractionTree children */ 3:
                    message.children.push(AttractionTree.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttractionTree, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sobject_id = 1; */
        if (message.sobjectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sobjectId);
        /* string attraction_id = 2; */
        if (message.attractionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.attractionId);
        /* repeated semio.model.v1.AttractionTree children = 3; */
        for (let i = 0; i < message.children.length; i++)
            AttractionTree.internalBinaryWrite(message.children[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.AttractionTree
 */
export const AttractionTree = new AttractionTree$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Layout$Type extends MessageType<Layout> {
    constructor() {
        super("semio.model.v1.Layout", [
            { no: 1, name: "sobjects", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Sobject },
            { no: 2, name: "attractions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Attraction },
            { no: 3, name: "strategy", kind: "enum", T: () => ["semio.model.v1.LayoutStrategy", LayoutStrategy] },
            { no: 4, name: "attraction_trees", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AttractionTree }
        ]);
    }
    create(value?: PartialMessage<Layout>): Layout {
        const message = { sobjects: [], attractions: [], strategy: 0, attractionTrees: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Layout>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Layout): Layout {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated semio.model.v1.Sobject sobjects */ 1:
                    message.sobjects.push(Sobject.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated semio.model.v1.Attraction attractions */ 2:
                    message.attractions.push(Attraction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* semio.model.v1.LayoutStrategy strategy */ 3:
                    message.strategy = reader.int32();
                    break;
                case /* repeated semio.model.v1.AttractionTree attraction_trees */ 4:
                    message.attractionTrees.push(AttractionTree.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Layout, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated semio.model.v1.Sobject sobjects = 1; */
        for (let i = 0; i < message.sobjects.length; i++)
            Sobject.internalBinaryWrite(message.sobjects[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated semio.model.v1.Attraction attractions = 2; */
        for (let i = 0; i < message.attractions.length; i++)
            Attraction.internalBinaryWrite(message.attractions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* semio.model.v1.LayoutStrategy strategy = 3; */
        if (message.strategy !== 0)
            writer.tag(3, WireType.Varint).int32(message.strategy);
        /* repeated semio.model.v1.AttractionTree attraction_trees = 4; */
        for (let i = 0; i < message.attractionTrees.length; i++)
            AttractionTree.internalBinaryWrite(message.attractionTrees[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Layout
 */
export const Layout = new Layout$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Element$Type extends MessageType<Element> {
    constructor() {
        super("semio.model.v1.Element", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "representations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Representation },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Element>): Element {
        const message = { id: "", representations: [], description: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Element>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Element): Element {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* repeated semio.model.v1.Representation representations */ 2:
                    message.representations.push(Representation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Element, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* repeated semio.model.v1.Representation representations = 2; */
        for (let i = 0; i < message.representations.length; i++)
            Representation.internalBinaryWrite(message.representations[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Element
 */
export const Element = new Element$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ElementTree$Type extends MessageType<ElementTree> {
    constructor() {
        super("semio.model.v1.ElementTree", [
            { no: 1, name: "element_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pose", kind: "message", T: () => Pose },
            { no: 3, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "parts", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ElementTree } }
        ]);
    }
    create(value?: PartialMessage<ElementTree>): ElementTree {
        const message = { elementId: "", type: "", parts: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ElementTree>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ElementTree): ElementTree {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string element_id */ 1:
                    message.elementId = reader.string();
                    break;
                case /* semio.model.v1.Pose pose */ 2:
                    message.pose = Pose.internalBinaryRead(reader, reader.uint32(), options, message.pose);
                    break;
                case /* string type */ 3:
                    message.type = reader.string();
                    break;
                case /* map<string, semio.model.v1.ElementTree> parts */ 4:
                    this.binaryReadMap4(message.parts, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: ElementTree["parts"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ElementTree["parts"] | undefined, val: ElementTree["parts"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ElementTree.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field semio.model.v1.ElementTree.parts");
            }
        }
        map[key ?? ""] = val ?? ElementTree.create();
    }
    internalBinaryWrite(message: ElementTree, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string element_id = 1; */
        if (message.elementId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.elementId);
        /* semio.model.v1.Pose pose = 2; */
        if (message.pose)
            Pose.internalBinaryWrite(message.pose, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string type = 3; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        /* map<string, semio.model.v1.ElementTree> parts = 4; */
        for (let k of Object.keys(message.parts)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ElementTree.internalBinaryWrite(message.parts[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.ElementTree
 */
export const ElementTree = new ElementTree$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Design$Type extends MessageType<Design> {
    constructor() {
        super("semio.model.v1.Design", [
            { no: 1, name: "elements", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Element },
            { no: 2, name: "elementTrees", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ElementTree }
        ]);
    }
    create(value?: PartialMessage<Design>): Design {
        const message = { elements: [], elementTrees: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Design>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Design): Design {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated semio.model.v1.Element elements */ 1:
                    message.elements.push(Element.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated semio.model.v1.ElementTree elementTrees */ 2:
                    message.elementTrees.push(ElementTree.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Design, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated semio.model.v1.Element elements = 1; */
        for (let i = 0; i < message.elements.length; i++)
            Element.internalBinaryWrite(message.elements[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated semio.model.v1.ElementTree elementTrees = 2; */
        for (let i = 0; i < message.elementTrees.length; i++)
            ElementTree.internalBinaryWrite(message.elementTrees[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Design
 */
export const Design = new Design$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayoutModification$Type extends MessageType<LayoutModification> {
    constructor() {
        super("semio.model.v1.LayoutModification", [
            { no: 1, name: "context", kind: "message", T: () => Layout },
            { no: 2, name: "modified_context", kind: "message", T: () => Layout }
        ]);
    }
    create(value?: PartialMessage<LayoutModification>): LayoutModification {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LayoutModification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayoutModification): LayoutModification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* semio.model.v1.Layout context */ 1:
                    message.context = Layout.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* semio.model.v1.Layout modified_context */ 2:
                    message.modifiedContext = Layout.internalBinaryRead(reader, reader.uint32(), options, message.modifiedContext);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LayoutModification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* semio.model.v1.Layout context = 1; */
        if (message.context)
            Layout.internalBinaryWrite(message.context, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* semio.model.v1.Layout modified_context = 2; */
        if (message.modifiedContext)
            Layout.internalBinaryWrite(message.modifiedContext, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.LayoutModification
 */
export const LayoutModification = new LayoutModification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayoutModificationStrategy$Type extends MessageType<LayoutModificationStrategy> {
    constructor() {
        super("semio.model.v1.LayoutModificationStrategy", [
            { no: 1, name: "match_count", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<LayoutModificationStrategy>): LayoutModificationStrategy {
        const message = { matchCount: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LayoutModificationStrategy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayoutModificationStrategy): LayoutModificationStrategy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 match_count */ 1:
                    message.matchCount = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LayoutModificationStrategy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 match_count = 1; */
        if (message.matchCount !== 0n)
            writer.tag(1, WireType.Varint).int64(message.matchCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.LayoutModificationStrategy
 */
export const LayoutModificationStrategy = new LayoutModificationStrategy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Decision$Type extends MessageType<Decision> {
    constructor() {
        super("semio.model.v1.Decision", [
            { no: 1, name: "modification", kind: "message", T: () => LayoutModification },
            { no: 2, name: "strategy", kind: "message", T: () => LayoutModificationStrategy }
        ]);
    }
    create(value?: PartialMessage<Decision>): Decision {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Decision>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Decision): Decision {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* semio.model.v1.LayoutModification modification */ 1:
                    message.modification = LayoutModification.internalBinaryRead(reader, reader.uint32(), options, message.modification);
                    break;
                case /* semio.model.v1.LayoutModificationStrategy strategy */ 2:
                    message.strategy = LayoutModificationStrategy.internalBinaryRead(reader, reader.uint32(), options, message.strategy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Decision, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* semio.model.v1.LayoutModification modification = 1; */
        if (message.modification)
            LayoutModification.internalBinaryWrite(message.modification, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* semio.model.v1.LayoutModificationStrategy strategy = 2; */
        if (message.strategy)
            LayoutModificationStrategy.internalBinaryWrite(message.strategy, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message semio.model.v1.Decision
 */
export const Decision = new Decision$Type();
