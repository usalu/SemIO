using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using Microsoft.CSharp;
using Microsoft.VisualBasic;
using SemIO.Parsing.ParserModels;
using SemIO.Parsing.ParserModels.Project;
using SemIO.Parsing.ParserModels.Project.AbstractionLevels;
using SemIO.Parsing.ParserModels.Project.AbstractionLevels.Objects;

namespace SemIO
{
    public class Compiler
    {
  
        /// <summary>
        ///  Compile semIO code and build it into C# or VB code and compile it directly into an assembly (dll).
        /// </summary>
        /// <param name="name">Name of the assembly</param>
        /// <param name="semIOCode">SemIO code to compile</param>
        /// <param name="assemblyFolder">Directory where a folder at Directory\CompilerResults will be created
        /// and all results get stored there.</param>
        /// <param name="description"></param>
        /// <returns>Returns the assembly or throw if error parsed information contains logical errors
        /// or the output path doesn't exist.</returns>
        public static CompilerResults CompileProjectAssembly(string name ,string semIOCode,
            string assemblyFolder = "" , string description = "This is an assembly auto-generated by the SemIO scripting language")
        {
            ProjectModel project = new ProjectModel(name, description, semIOCode);

            //throw error if there is no abstraction level
            if (project.AbstractionLevels.Count == 0)
                throw new Exception("No abstraction level could be found");

            //current directory if no path supplied
            if (assemblyFolder == "")
                assemblyFolder = Directory.GetCurrentDirectory();
            if (!assemblyFolder.EndsWith(@"\"))
                assemblyFolder = assemblyFolder + @"\";
            System.IO.Directory.CreateDirectory(assemblyFolder + $@"CompilerResults");

            var cSharpCodeProvider = new CSharpCodeProvider();
            var vbCodeProvider = new VBCodeProvider();
            var jSCodeProvider = CodeDomProvider.CreateProvider("JScript");
            var cPPCodeProvider = CodeDomProvider.CreateProvider("C++");
            //var cPPCodeProvider = CodeDomProvider.CreateProvider("C");

            //compile unit that contains the whole project
            CodeCompileUnit projectCompileUnit = new CodeCompileUnit();
            projectCompileUnit.Namespaces.AddRange(GetProjectNamespacesCollection(project));

            //compilation of the dll
            CompilerResults cr = cSharpCodeProvider.CompileAssemblyFromDom(new CompilerParameters
            {
                GenerateExecutable = false,
                OutputAssembly = $@"{assemblyFolder}CompilerResults\{project.Name}.dll",
                GenerateInMemory = false,
                TreatWarningsAsErrors = false,
                ReferencedAssemblies =
                    {"System.dll", "SemIOLibrary.dll"}
            }, projectCompileUnit);

            //options for the layout of the generated C# and VB code
            var codeGeneratorOptions = new CodeGeneratorOptions()
            {
                BracingStyle = "C",
                BlankLinesBetweenMembers = true,
                IndentString = "    ",
                ElseOnClosing = false,
                VerbatimOrder = true
            };

            //generated C# code
            StringWriter stringWriterCSharp = new StringWriter();
            cSharpCodeProvider.GenerateCodeFromCompileUnit( projectCompileUnit, stringWriterCSharp, codeGeneratorOptions);
            System.IO.File.WriteAllText($@"{assemblyFolder}CompilerResults\{project.Name}.cs", stringWriterCSharp.ToString());

            //generated VB code
            StringWriter stringWriterVB = new StringWriter();
            vbCodeProvider.GenerateCodeFromCompileUnit(projectCompileUnit, stringWriterVB, codeGeneratorOptions);
            System.IO.File.WriteAllText($@"{assemblyFolder}CompilerResults\{project.Name}.vb", stringWriterVB.ToString());

            //generated JS code
            StringWriter stringWriterJS = new StringWriter();
            jSCodeProvider.GenerateCodeFromCompileUnit(projectCompileUnit, stringWriterJS, codeGeneratorOptions);
            System.IO.File.WriteAllText($@"{assemblyFolder}CompilerResults\{project.Name}.js", stringWriterJS.ToString());

            //generated C++ code
            StringWriter stringWriterCPP = new StringWriter();
            cPPCodeProvider.GenerateCodeFromCompileUnit(projectCompileUnit, stringWriterCPP, codeGeneratorOptions);
            System.IO.File.WriteAllText($@"{assemblyFolder}CompilerResults\{project.Name}.cpp", stringWriterCPP.ToString());


            return cr;
        }

        /// <summary>
        /// Retrieve a CodeNamespaceCollection that describes the project.
        /// </summary>
        /// <param name="project">A project model containing abstraction layers</param>
        /// <returns>All namespaces for compilation</returns>
        private static CodeNamespaceCollection GetProjectNamespacesCollection(ProjectModel project)
        {
            var abstractionLevelNamespaces = new CodeNamespaceCollection();
            foreach (var namespaceCollection in project.AbstractionLevels.Select(GetAbstractionLevelNamespaces))
                abstractionLevelNamespaces.AddRange(namespaceCollection);
            return abstractionLevelNamespaces;
        }
        /// <summary>
        /// Retrieve a CodeNamespaceCollection that describes one abstraction level
        /// </summary>
        /// <param name="abstractionLevel">The abstraction level with parameter types and objects</param>
        /// <returns>The namespaces with all generated code for parameter types and objects</returns>
        private static CodeNamespaceCollection GetAbstractionLevelNamespaces(AbstractionLevelModel abstractionLevel)
        {
            CodeNamespaceCollection abstractionLevelNamespaces = new CodeNamespaceCollection();

            //AbstractionLevels is the basic namespace of most objects in the assembly
            //Only benchmarks will be not located on an abstraction level
            string repositoryName = "AbstractionLevels." + abstractionLevel.Name + "Repository";

            //add parameter types
            string parameterTypesNamespaceName = repositoryName + ".ParameterTypes";
            CodeNamespace parameterTypesNamespace = new CodeNamespace(parameterTypesNamespaceName);
            parameterTypesNamespace.Imports.Add(new CodeNamespaceImport("System"));
            parameterTypesNamespace.Types.AddRange(abstractionLevel.ParameterTypes.Select(GetParameterType).ToArray());
            abstractionLevelNamespaces.Add(parameterTypesNamespace);

            //Add object types
            string objectsNamespaceName = repositoryName + ".ObjectTypes";
            CodeNamespace objectTypesNamespace = new CodeNamespace(objectsNamespaceName);
            //base import + parameter types for parameter property
            List<CodeNamespaceImport> objectImports = new List<CodeNamespaceImport>()
            {
                new CodeNamespaceImport("System"),
                new CodeNamespaceImport(parameterTypesNamespaceName),
            };
            //Adding all the missing semIOLibrary namespaces with reflection so parameter can take value of parameter
            List<string> semIOLibraryNamespaces = new List<string>();
            foreach (var type in Assembly.Load("SemIOLibrary").GetTypes())
                if (!semIOLibraryNamespaces.Exists(x => type.Namespace == x))
                    semIOLibraryNamespaces.Add(type.Namespace);
            objectImports.AddRange(semIOLibraryNamespaces.Select(x => new CodeNamespaceImport(x)));
            objectTypesNamespace.Imports.AddRange(objectImports.ToArray());
            foreach (var objectType in abstractionLevel.ObjectTypes)
                objectTypesNamespace.Types.Add(GetObjectType(objectType));
            abstractionLevelNamespaces.Add(objectTypesNamespace);
            
            //Add goal types, Left to implement

            //Add index types, Left to implement

            //Add function types, Left to implement

            //build final abstraction level class
            var abstractionLevelNamespace =new CodeNamespace(repositoryName)
            {
                Types =
                {
                    GetAbstractionLevelType(abstractionLevel)
                },
                Imports =
                {
                    new CodeNamespaceImport("System"),
                    new CodeNamespaceImport(objectsNamespaceName),
                }
            };
            //If their exists a parent abstraction level the using directive needs to be added
            if(abstractionLevel.ParentAbstractionLevelName!="")
                abstractionLevelNamespace.Imports.Add(new CodeNamespaceImport(
                "AbstractionLevels." + abstractionLevel.ParentAbstractionLevelName + "Repository"));
            abstractionLevelNamespaces.Add(abstractionLevelNamespace);

            return abstractionLevelNamespaces;
        }

        /// <summary>
        /// Build a code type declaration that contains all the information to generate
        /// a proper type for an abstraction level in the assembly
        /// </summary>
        /// <param name="abstractionLevel"></param>
        /// <returns>Type declaration with all a list property for all created objects</returns>
        private static CodeTypeDeclaration GetAbstractionLevelType(AbstractionLevelModel abstractionLevel)
        {
            CodeTypeDeclaration abstractionLevelTypeDeclaration = new CodeTypeDeclaration(abstractionLevel.Name)
            {
                IsClass = true,
                CustomAttributes =
                {
                    new CodeAttributeDeclaration("System.ComponentModel.Description",
                        new CodeAttributeArgument(new CodePrimitiveExpression(abstractionLevel.Description)))
                }
            };
            
            //add a list<object> property for every object type to the abstraction level type
            foreach (ObjectModel objectType in abstractionLevel.ObjectTypes)
                abstractionLevelTypeDeclaration.Members.AddRange(GetParameterCollectionPropertyCollection(objectType));

            //add the parent abstraction level to as inheritance in case there exists one
            if (abstractionLevel.ParentAbstractionLevelName != "")
                abstractionLevelTypeDeclaration.BaseTypes.Add(abstractionLevel.ParentAbstractionLevelName);
            
            return abstractionLevelTypeDeclaration;
        }

        /// <summary>
        /// Build a code type declaration that for a parameter type which will be a an enum type.
        /// It will contain the attribute flags if the parameter is a multiset
        /// and the values will be adjusted to 2^i so the bitwise operator works fine.
        /// </summary>
        /// <param name="parameterType">The parameter type will all the values und their descriptions</param>
        /// <returns>Type declaration to build the (optionally flagged) enum type</returns>
        private static CodeTypeDeclaration GetParameterType(ParameterType parameterType)
        {
            CodeTypeDeclaration parameterCodeTypeDeclaration = new CodeTypeDeclaration(parameterType.ParameterTypeName)
            {
                IsEnum = true,
                CustomAttributes =
                {
                    new CodeAttributeDeclaration("System.ComponentModel.Description",
                        new CodeAttributeArgument(new CodePrimitiveExpression(parameterType.Description)))
                }
            };

            //add the Flags attribute to ensure a multiset
            if (parameterType.IsMultiset)
                parameterCodeTypeDeclaration.CustomAttributes.Add(new CodeAttributeDeclaration("Flags"));

            //add values with the right value und a description attribute 
            for (int i = 0; i < parameterType.ValueCount(); i++)
            {
                var enumMember = new CodeMemberField();
                if (parameterType.ValueDescriptions[i] != null)
                    enumMember.CustomAttributes.Add(new CodeAttributeDeclaration("System.ComponentModel.Description",
                        new CodeAttributeArgument(
                            new CodePrimitiveExpression(parameterType.ValueDescriptions[i] ?? ""))));
                enumMember.Name = parameterType.NameValues[i];
                enumMember.InitExpression =
                    new CodePrimitiveExpression(parameterType.IsMultiset ? (int) Math.Pow(2, i) : i);
                parameterCodeTypeDeclaration.Members.Add(enumMember);
            }

            return parameterCodeTypeDeclaration;
        }

        /// <summary>
        ///  Build a code type declaration that contains all information to build a proper type for an
        /// object of an abstraction level. The parameters are either way other objects, parameter types or
        /// types from the semIOLibrary.
        /// </summary>
        /// <param name="objectType">The abstraction level object type</param>
        /// <returns>Type declaration with all parameters</returns>
        private static CodeTypeDeclaration GetObjectType(ObjectModel objectType)
        {
            CodeTypeDeclaration objectCodeTypeDeclaration = new CodeTypeDeclaration(objectType.Name)
            {
                IsClass = true,
                CustomAttributes =
                {
                    new CodeAttributeDeclaration("System.ComponentModel.Description",
                        new CodeAttributeArgument(new CodePrimitiveExpression(objectType.Description)))
                }
            };

            foreach (var parentName in objectType.ParentNames)
                objectCodeTypeDeclaration.BaseTypes.Add(parentName);
            
            //setting up all the parameters of that object
            foreach (var parameter in objectType.Parameters)
                objectCodeTypeDeclaration.Members.AddRange(GetParameterPropertyCollection(parameter));

            return objectCodeTypeDeclaration;
        }

        /// <summary>
        /// Get a public property with a simple get and set method and a private member field
        /// for a class for a generic parameter. This parameter can be an object, a parameter type.
        /// </summary>
        /// <param name="parameter">A generic parameter that contains a name, a type and description</param>
        /// <returns>The property with get and set method and the field member</returns>
        private static CodeTypeMemberCollection GetParameterPropertyCollection(IParameter parameter)
        {
            CodeTypeMemberCollection propertiesMemberCollection = new CodeTypeMemberCollection();

            //naming the private field in C# naming convention with _lowercaseName
            string parameterFieldName = "_" + char.ToLower(parameter.Name[0]) + parameter.Name.Substring(1);
            //adding private field field
            propertiesMemberCollection.Add(new CodeMemberField(parameter.ParameterTypeName, parameterFieldName));
            //adding public property with simple get and set method
            propertiesMemberCollection.Add(new CodeMemberProperty()
            {
                CustomAttributes =
                {
                    new CodeAttributeDeclaration("System.ComponentModel.Description",
                        new CodeAttributeArgument(new CodePrimitiveExpression(parameter.Description)))
                },
                Attributes = MemberAttributes.Public | MemberAttributes.Final,
                Name = parameter.Name,
                Type = new CodeTypeReference(parameter.ParameterTypeName),
                HasGet = true,
                HasSet = true,
                GetStatements =
                {
                    new CodeMethodReturnStatement(new CodeFieldReferenceExpression(
                        new CodeThisReferenceExpression(), parameterFieldName))
                },
                SetStatements =
                {
                    new CodeAssignStatement( new CodeFieldReferenceExpression(
                            new CodeThisReferenceExpression(), parameterFieldName),
                        new CodePropertySetValueReferenceExpression())
                },
            });

            return propertiesMemberCollection;
        }

        /// <summary>
        /// Get a public list (of generic type: parameter) property with only a get method
        /// and a private field member for a class declaration.
        /// </summary>
        /// <param name="parameter">Generic parameter for the type of the list</param>
        /// <returns>Public get only property and private field member</returns>
        private static CodeTypeMemberCollection GetParameterCollectionPropertyCollection(IParameter parameter)
        {
            CodeTypeMemberCollection propertiesMemberCollection = new CodeTypeMemberCollection();

            string parameterFieldName = "_" + char.ToLower(parameter.Name[0]) + parameter.Name.Substring(1) + "Collection";
            
            //type of list of parameter type
            var listType = new CodeTypeReference(typeof(List<>));
            listType.TypeArguments.Add(parameter.ParameterTypeName);

            //adding private field field
            propertiesMemberCollection.Add(new CodeMemberField(listType, parameterFieldName));
            //adding public property with get method only. No set because of the list
            propertiesMemberCollection.Add(new CodeMemberProperty()
            {
                CustomAttributes =
                {
                    new CodeAttributeDeclaration("System.ComponentModel.Description",
                        new CodeAttributeArgument(new CodePrimitiveExpression(parameter.Description)))
                },
                Attributes = MemberAttributes.Public | MemberAttributes.Final,
                Name = parameter.Name + "Collection",
                Type = listType,
                HasGet = true,
                HasSet = true,
                GetStatements =
                {
                    new CodeMethodReturnStatement(new CodeFieldReferenceExpression(
                        new CodeThisReferenceExpression(), parameterFieldName))
                }
            });
            
            return propertiesMemberCollection;
        }

    }
}