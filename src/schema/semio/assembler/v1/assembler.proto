syntax = "proto3";

package semio.assembler.v1;

option go_package = "github.com/usalu/semio/src/packages/go/assembler/v1";
option csharp_namespace = "Semio.Assembler.V1";

import "model/v1/model.proto";

// The assembler service is responsible for assembling layouts into designs.
service AssemblerService {
  // Turn a layout into assemblies.
  rpc LayoutToAssemblies(semio.model.v1.Layout) returns (LayoutToAssembliesResponse);
  // Assemble elements from an assembly.
  rpc AssemblyToElements(AssemblyToElementsRequest) returns (AssemblyToElementsResponse);
}

message LayoutToAssembliesRequest{
  semio.model.v1.Layout layout = 1;
  LayoutStrategy strategy = 2;
  // Optional assemblies that can possibly unambiguously describe the layout order of sobjects.
  // Most of the time this field is only necissary when elements that don't work well together in a general way.
  // Therefore if you can update the element definitions to be more robust, rather use your time for that.
  repeated Assembly assemblies = 4;
}

// A layout strategy affects in which orders connections are triggered.
enum LayoutStrategy {
  // A breadth first layout strategy will connect all neighbours first before these start to do the same with their neighbours.
  LAYOUTSTRATEGY_BREADTHFIRST = 0;
  // A depth first layout strategy will always prioritize to choose the neighbour of the neighbour first before the other neighbours of the root.
  LAYOUTSTRATEGY_DEPTHFIRST = 1;
}

message LayoutToAssembliesResponse{
  repeated semio.model.v1.Assembly assemblies = 1;
}

message AssemblyToElementsRequest {
  semio.model.v1.Assembly assembly = 1;
  repeated semio.model.v1.Sobject sobjects = 2;
  repeated semio.model.v1.Connection connections = 3;
}

message AssemblyToElementsResponse {
  repeated semio.model.v1.Element elements = 1;
}