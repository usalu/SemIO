syntax = "proto3";

package semio.model.v1;

option go_package = "github.com/usalu/semio/src/packages/go/model/v1";
option csharp_namespace = "Semio.Model.V1";

// A 3d point with x,y,z coordinates.
message Point {
  // x coordinate.
  double x = 1;
  // y coordinate
  double y = 2;
  // z coordinate
  double z = 3;
}

// Quaternions represent (here) (rotational) orientation. It can be interpreted as the view of an element.  
message Quaternion {
  double w = 1;
  double x = 2;
  double y = 3;
  double z = 4;
}

// A pose is a reference frame with a point of view (origin) and orientation (view).
message Pose {
  Point point_of_view = 1;
  Quaternion view = 2;
}

// A representation for an element. Basically a file with some semio specific metadata.
message Representation {
  // The body depends on the serilization format of the representation.
  bytes body = 1;
  // Encoding of the body
  Encoding encoding = 2;
  // Use the abbrebivatation of the platform. You can find that in the constants part of the package.
  FileType file_type = 3;
  // Platform
  Platform platform = 4;
  // Name of representation. This can be used for visualization purpose (e.g. conceptual, detailed, ...) or for functional purpose (e.g. statical, energetical, ...)
  string name = 5;
  // Level of detail allows to further define representation details. Like name this can be used either for visualizaztion purpose (e.g. 200 (scale 1to200)) or functional purpose (e.g level of structural detail)
  int64 lod = 6;
}

// Encoding of a byte array.
enum Encoding {
  ENCODING_TEXT_UFT8 = 0;
  ENCODING_TEXT_UFT16 = 1;
  ENCODING_TEXT_UFT32 = 2;
  ENCODING_TEXT_ASCII = 3;
  // Also ASCII but with further base 64 encoding of the text.
  ENCODING_TEXT_BASE64 = 4;
}

enum FileType {
  // Native binary according platform. Use this only when it really is binary otherwise try to figure out what the file type is.
  FILETYPE_NATIVEBINARY = 0;
  FILETYPE_JSON = 1;
  FILETYPE_XML = 2;
  FILETYPE_YAML = 3;
  FILETYPE_TOML = 4;
  // https://www.iso.org/standard/63141.html
  FILETYPE_STEP = 5;
  // Python
  FILETYPE_PY = 6;
  FILETYPE_C = 7;
  // C++
  FILETYPE_CPP = 8;
  // C#
  FILETYPE_CSHARP = 9;
  // Golang
  FILETYPE_GO = 10;
  // Rust
  FILETYPE_RUST = 11;
}

// Platform. Constants are encoded with pattern LICENSE [3] + OWNERTYPE [2] + OWNERID [3] + PLATFORMID [2]
// LICENSE after https://spdx.org/licenses/: 
// 0:AGPL-3.0-or-later,
// 50:GPL-3.0+,51:GPL-3.0,52:GPL-2.0+,53:GPL-2.0
// 100:LGPL-3.0-or-later,101:LGPL-3.0-only
// 150:MIT,160:Apache-2.0,170:0BSD
// 214:Closed
// OWNER starting with OWNERTYPE:
// 0:INDIVIDUALS: 0:usalu,1:mrdoob,2:nortikin,3:hannobraun,4:ricosjp
// 1:COLLECTIVE: 0:ifcopenshell,1:cadquery,2:freecad,3:openscad,4:jscad
// 2:NONPROFIT: 0:buildingsmart
// 3:COMPANY: 0:mcneel,1:autodesk,2:nemetschek,3:esri
enum Platform {
  // https://github.com/usalu/semio
  PLATFORM_SEMIO = 0;
  // https://github.com/mrdoob/three.js/
  PLATFORM_THREE = 1000000100;
  // https://github.com/nortikin/sverchok
  PLATFORM_SVERCHOK = 500000200;
  // https://github.com/IfcOpenShell
  PLATFORM_IFCOPENSHELL = 1010100000;
  // https://github.com/CadQuery
  PLATFORM_CADQUERY = 1600100100;
  // https://github.com/FreeCAD
  PLATFORM_FREECAD = 530100200;
  // https://github.com/openscad
  PLATFORM_OPENSCAD = 530100300;
  // https://github.com/jscad
  PLATFORM_JSCAD = 1500100400;
  // https://github.com/hannobraun/Fornjot
  PLATFORM_Fornjot = 1700000300;
  // https://github.com/ricosjp/truck
  PLATFORM_TRUCK = 1500000400;
  // https://www.rhino3d.com/
  PLATFORM_RHINO = 2140300000;
  // https://www.grasshopper3d.com/
  PLATFORM_GRASSHOPPER = 2140300001;
  // https://www.autodesk.de/products/revit/
  PLATFORM_REVIT = 2140300100;
  // https://dynamobim.org/
  PLATFORM_DYNAMO = 2140300101;
}

// Instance information for an element.
message Sobject {
  // Id that allows to distinguish it from other sobjects.
  string id = 1;
  // The url of the element definition.
  string url = 2;
  // The (rough) pose of the sobject. Note that in the attraction process it will most likely be displaced and adjusted.
  Pose pose = 3;
  // Parameters for the element.
  map<string,string> parameters = 4;
}

// The representation protocol determines what type of representation the attractor will see of the attracted in the attraction process.
enum RepresentationProtocol{
  // The attractor sees no representation of the attracted.
  REPRESENTATIONPROTOCOL_NONE = 0;
  // In the simple representation protocol everything is representatedby a point.
  REPRESENTATIONPROTOCOL_SIMPLE = 1;
  // In the full representation protocol everything is representatedby it's native form where all information is available. This will most likely lead to strong coupled elements. Only use when absolutletly necissary.
  REPRESENTATIONPROTOCOL_FULL = 2;
}

// An attraction participant participates in an attraction process.
message AttractionParticipant {
  // Id of participating sobject.
  string participant_id = 1;
  // An optional representation of the participant.
  RepresentationProtocol representationProtocol = 2;
  // Optional port names to connect to. The hierarchy should matter
  repeated string ports = 3;
  // Optional parameters to bias the attraction.
  map<string,string> bias = 4;
}

// An attraction can be used to attract an attracted attraction participant to an attractor attraction participant.
message Attraction {
  // Id that allows to distinguish it from other attractions.
  string id = 1;
  // The attractor is expected to be the fixed sobject.
  AttractionParticipant attractor = 2;
  // The attracted is expected to be the flexible sobject that adjusts its point of view.
  AttractionParticipant attracted = 3;
}

// An attraction tree contains exact information in which order attractions should be triggered.
message AttractionTree{
  string attraction_id = 1;
  repeated AttractionTree children = 2;
}

// A layout strategy affects in which orders attractions are triggered.
enum LayoutStrategy {
  // A breadth first layout strategy will attract all neighbours first before these start to the same with their neighbours.
  LAYOUTSTRATEGY_BREADTHFIRST = 0;
  // A depth first layout strategy will always prioritize to choose the neighbour of the neighbour first before the other neighbours of the root.
  LAYOUTSTRATEGY_DEPTHFIRST = 1;
}

// A layout (graph) is an assembly plan for a set of sobjects and their attractions between each other.
message Layout {
  repeated Sobject sobjects = 1;
  repeated Attraction attractions = 2;
  // Sobject that anker the layout.
  repeated string roots_sobjects_ids = 3;
  LayoutStrategy strategy = 4;
  // Optional attraction trees.
  repeated AttractionTree attractionTrees = 5;
}

// An element is the atom of a design. It has several representations and a pose.
message Element {
  Pose pose = 1;
  repeated Representation representations = 2;
}

// A design is an aggregation of elements.
message Design {
  repeated Element elements = 1;
}

// A layout modification describes declaratively a layout and the layout after its modification. The rules on how to imperatively change such a layout need to found by the transformation system.
message LayoutModification {
  Layout context = 1;
  Layout modified_context = 2;
}

// A decision strategy holds information on how modifications are applied.
message LayoutModificationStrategy {
  // The match count describes how often a layout modification should be applied. It beeing finite will make sure that the system always terminates. Make sure to set the threshold high enough.
  int64 match_count = 1;
}

// A decision is a layout modification with a strategy on how to apply it to a new layout.
message Decision {
  LayoutModification modification = 1;
  LayoutModificationStrategy strategy = 2;
}
