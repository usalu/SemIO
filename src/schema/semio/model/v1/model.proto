syntax = "proto3";

package semio.model.v1;

option go_package = "github.com/usalu/semio/src/packages/go/model/v1";
option csharp_namespace = "Semio.Model.V1";

// A 3d point with x,y,z coordinates.
message Point {
  // x coordinate.
  double x = 1;
  // y coordinate
  double y = 2;
  // z coordinate
  double z = 3;
}

// Quaternions represent (here) (rotational) orientation. It can be interpreted as the view of an element.  
message Quaternion {
  double w = 1;
  double x = 2;
  double y = 3;
  double z = 4;
}

// A pose is a reference frame with a point of view (origin) and orientation (view).
message Pose {
  Point point_of_view = 1;
  Quaternion view = 2;
}

// A representation for an element.
message Representation {
  // Use the abbrebivatation of the platform. You can find that in the constants part of the package.
  string type = 1;
  // Name of representation. This can be used for visualization purpose (e.g. conceptual, detailed, ...) or for functional purpose (e.g. statical, energetical, ...)
  string name = 2;
  // Level of detail allows to further define representation details. Like name this can be used either for visualizaztion purpose (e.g. 200 (scale 1to200)) or functional purpose (e.g level of structural detail)
  int64 lod = 3;
  // The body depends on the serilization format of the representation.
  oneof body {
    // A byte array is an encoded and optimized body that needs a dedicated package to read the content.
    bytes byteArray = 4;
    // A textual body is typical readable by humans and computers often allowing to be usefully read even outside the official packages.
    string text = 5;
  }
}

// Instance information for an element.
message Sobject {
  // Id that allows to distinguish it from other sobjects.
  string id = 1;
  // The url of the element definition.
  string url = 2;
  // The (rough) pose of the sobject. Note that in the attraction process it will most likely be displaced and adjusted.
  Pose pose = 3;
  // Parameters for the element.
  map<string,string> parameters = 4;
}

// The representation protocol determines what type of representation the attractor will see of the attracted in the attraction process.
enum RepresentationProtocol{
  // The attractor sees no representation of the attracted.
  REPRESENTATIONPROTOCOL_NONE = 0;
  // In the simple representation protocol everything is representatedby a point.
  REPRESENTATIONPROTOCOL_SIMPLE = 1;
  // In the full representation protocol everything is representatedby it's native form where all information is available. This will most likely lead to strong coupled elements. Only use when absolutletly necissary.
  REPRESENTATIONPROTOCOL_FULL = 2;
}

// An attraction participant participates in an attraction process.
message AttractionParticipant {
  // Id of participating sobject.
  string patricipant_id = 1;
  // An optional representation of the participant.
  RepresentationProtocol representationProtocol = 2;
  // Optional port names to connect to. The hierarchy should matter
  repeated string ports = 3;
  // Optional parameters to bias the attraction.
  map<string,string> bias = 4;
}

// An attraction can be used to attract an attracted attraction participant to an attractor attraction participant.
message Attraction {
  // Id that allows to distinguish it from other attractions.
  string id = 1;
  // The attractor is expected to be the fixed sobject.
  AttractionParticipant attractor = 2;
  // The attracted is expected to be the flexible sobject that adjusts its point of view.
  AttractionParticipant attracted = 3;
}

// An attraction tree contains exact information in which order attractions should be triggered.
message AttractionTree{
  string attraction_id = 1;
  repeated AttractionTree children = 2;
}

// A layout strategy affects in which orders attractions are triggered.
enum LayoutStrategy {
  // A breadth first layout strategy will attract all neighbours first before these start to the same with their neighbours.
  LAYOUTSTRATEGY_BREADTHFIRST = 0;
  // A depth first layout strategy will always prioritize to choose the neighbour of the neighbour first before the other neighbours of the root.
  LAYOUTSTRATEGY_DEPTHFIRST = 1;
}

// A layout (graph) is an assembly plan for a set of sobjects and their attractions between each other.
message Layout {
  repeated Sobject sobjects = 1;
  repeated Attraction attractions = 2;
  // This sobject acts as an anker in the layout.
  string root_sobject_id = 3;
  LayoutStrategy stragegy = 4;
  // Optional attraction trees with root sobject id as key and attraction tree as value.
  repeated AttractionTree attractionTrees = 5;
}

// An element is the atom of a design. It has several representations and a pose.
message Element {
  Pose pose = 1;
  repeated Representation representations = 2;
}

// A design is an aggregation of elements.
message Design {
  repeated Element elements = 1;
}

// A layout modification describes declaratively a layout and the layout after its modification. The rules on how to imperatively change such a layout need to found by the transformation system.
message LayoutModification {
  Layout context = 1;
  Layout modified_context = 2;
}

// A decision strategy holds information on how modifications are applied.
message LayoutModificationStrategy {
  // The match count describes how often a layout modification should be applied. It beeing finite will make sure that the system always terminates. Make sure to set the threshold high enough.
  int64 match_count = 1;
}

// A decision is a layout modification with a strategy on how to apply it to a new layout.
message Decision {
  LayoutModification modification = 1;
  LayoutModificationStrategy strategy = 2;
}
