syntax = "proto3";

package semio.model.v1;

option go_package = "github.com/usalu/semio/src/packages/go/model/v1";
option csharp_namespace = "Semio.Model.V1";

import "google/protobuf/timestamp.proto";

import "geometry/v1/geometry.proto";

// 🔢 Encoding of a byte array.
enum Encoding {
  ENCODING_UFT8 = 0;
  ENCODING_UFT16 = 1;
  ENCODING_UFT32 = 2;
  ENCODING_ASCII = 3;
  // Also ASCII but with further base 64 encoding of the text.
  ENCODING_BASE64 = 4;
}

// A body type defines
enum Serialization {
  // When there is no common 
  SERIALIZATION_BYTES = 0;
  // Custom text serialization according platform.
  // Often files have a platform specific extension but if you open them in a text editor you can see that they are serialized in a standard format.
  SERIALIZATION_TEXT = 1;
  SERIALIZATION_JSON = 2;
  SERIALIZATION_XML = 3;
  SERIALIZATION_YAML = 4;
  SERIALIZATION_TOML = 5;
  // https://www.iso.org/standard/63141.html
  SERIALIZATION_STEP = 6;
}

// Platform. Constants are encoded with pattern LICENSE [3] + OWNERTYPE [2] +  OWNERID [3] + PLATFORMID [2] < max (int32) = 2,147,483,647
// LICENSE (if possible after https://spdx.org/licenses/): 
// 0:AGPL-3.0-or-later,
// 50:GPL-3.0+,51:GPL-3.0,52:GPL-2.0+,53:GPL-2.0
// 100:LGPL-3.0-or-later,101:LGPL-3.0-only
// 150:MIT,160:Apache-2.0,
// 170:0BSD
// 190:EnergyPlus
// 214:Closed
// OWNERID after OWNERTYPE:
// 0:INDIVIDUALS: 0:usalu,1:mrdoob,2:nortikin,3:hannobraun,4:ricosjp
// 1:COLLECTIVE: 0:ifcopenshell,1:cadquery,2:freecad,3:openscad,4:jscad
// 2:NONPROFIT: 0:buildingsmart,1:nrel
// 3:COMPANY: 0:mcneel,1:autodesk,2:nemetschek,3:esri,4:microsoft, 500:speckle,501:hypar
enum Platform {
  // https://github.com/usalu/semio
  PLATFORM_SEMIO = 0;
  // https://github.com/specklesystems
  PLATFORM_SPECKLE = 1600350000;
  // https://github.com/mrdoob/three.js/
  PLATFORM_THREE = 1000000100;
  // https://github.com/nortikin/sverchok
  PLATFORM_SVERCHOK = 500000200;
  // https://github.com/IfcOpenShell
  PLATFORM_IFCOPENSHELL = 1010100000;
  // https://github.com/CadQuery
  PLATFORM_CADQUERY = 1600100100;
  // https://github.com/FreeCAD
  PLATFORM_FREECAD = 530100200;
  // https://github.com/openscad
  PLATFORM_OPENSCAD = 530100300;
  // https://github.com/jscad
  PLATFORM_JSCAD = 1500100400;
  // https://github.com/hannobraun/Fornjot
  PLATFORM_FORNJOT = 1700000300;
  // https://github.com/ricosjp/truck
  PLATFORM_TRUCK = 1500000400;
  // https://github.com/NREL/EnergyPlus
  PLATFORM_ENERGYPLUS = 1900200100;
  // https://github.com/NREL/OpenStudio
  PLATFORM_OPENSTUDIO = 1910200101;
  // https://www.rhino3d.com/
  PLATFORM_RHINO = 2140300000;
  // https://www.grasshopper3d.com/
  PLATFORM_GRASSHOPPER = 2140300001;
  // https://www.autodesk.de/products/revit/
  PLATFORM_REVIT = 2140300100;
  // https://dynamobim.org/
  PLATFORM_DYNAMO = 2140300101;
  // https://graphisoft.com/solutions/archicad
  PLATFORM_ARCHICAD = 2140300200;
  // https://www.esri.com/en-us/arcgis/products/arcgis-cityengine
  PLATFORM_CITYENGINE = 2140300300;
  // https://www.microsoft.com/en-us/microsoft-365/excel
  PLATFORM_EXCEL = 2140300400;
  // https://hypar.io/
  PLATFORM_HYPAR = 2140350100;
}

// TODO: Add structured way of determining
// Datamodel. Constants are encoded with pattern LICENSE [3] + OWNERTYPE [2] +  OWNERID [3] + PLATFORMID [2] < max (int32) = 2,147,483,647
// LICENSE (if possible after https://spdx.org/licenses/): 
// 0:AGPL-3.0-or-later,
// 50:GPL-3.0+,51:GPL-3.0,52:GPL-2.0+,53:GPL-2.0
// 100:LGPL-3.0-or-later,101:LGPL-3.0-only
// 150:MIT,160:Apache-2.0,
// 170:0BSD
// 190:EnergyPlus
// 214:Closed
// OWNERID after OWNERTYPE:
// 0:INDIVIDUALS: 0:usalu,1:mrdoob,2:nortikin,3:hannobraun,4:ricosjp
// 1:COLLECTIVE: 0:ifcopenshell,1:cadquery,2:freecad,3:openscad,4:jscad
// 2:NONPROFIT: 0:buildingsmart,1:nrel
// 3:COMPANY: 0:mcneel,1:autodesk,2:nemetschek,3:esri,4:microsoft, 500:speckle,501:hypar
enum Language {
  LANGUAGE_TEXT = 0;
  LANGUAGE_IFC = 1;
  LANGUAGE_SPECKLE = 2;
  LANGUAGE_SPECKLE = 2;
}

// A model is basically a file with metadata.
message Model {
  // The raw body of the model.
  bytes body = 1;
  // The platform where the model can be interpreted.
  Platform platform = 2;
  // Optional encoding of the body if the model is stored as a text format.
  Encoding encoding = 3;
  // Optional file type if the model is in a text format and a common file type.
  Serialization body_type = 4;
  // Optional metadata for a model
  message Metadata{
    // Name of the model
    string name = 1;
    // A description of the model for humans to understand what the purpose of this model is.
    string description = 2;
    // Timestamp when the model was created.
    google.protobuf.Timestamp timestamp_created = 3;
    // The platform in which the model was created.
    Platform modelling_platform = 4;
    // Author of the model.
    string author = 5;
    // Add a list of concepts that help filtering models. This can be used for functional purpose (e.g. statical, energetical, ...) or for visualization purpose (e.g. volumetric,comic, , ...). 
    repeated string concepts = 6;
    // Level of detail allows to further define model details. Like name this can be used either for visualization purpose (e.g. 200 (scale 1to200)) or functional purpose (e.g level of structural detail)
    // For architectural design it is recommended to choose the scale multiplier.
    // For BIM you might want to choose:
    // 100:Conceptual
    // 200:Approximate
    // 300:Precise
    // 400:Fabriaction
    // 500:Real 
    int32 lod = 7;
  }
}

// Describes the scope of a parameter.
message Scope {
  // Concept for the scope e.g Fassade, Floor
  string concept = 1;
  // Optionally define the order. Othwerwise it will be implicitly ordered by declaration order.
  int32 order = 2; 
}

// A value that will tried to mapped to a native type in the corresponding platform.
message Value {
  oneof value {
    string text = 1;
    double number = 2;
    int32 integer_number = 3;
    uint32 natural_number = 4;
    semio.geometry.v1.Point point = 5;
  }
}

// 🎚️ A parameter is a (common) object that can be used as a parameter in all platforms.
message Parameter {
  // Name of the parameter
  string name = 1;
  // Value of the parameter.
  Value value = 2;
  // Optional context field to describe the context of the parameter.
  repeated Scope context = 3;
}

// 🛠️ A plan of a script.
message Plan {
  // 🔗 The uri of the script.
  string uri = 1;
  // 🎛️ Optional parameters for the prototype.
  repeated Parameter parameters = 2;
}

//  A sobject is a virtual object which can be connected with other sobjects.
//  It has all semantical information, so that a definition information for an element can produce it.
message Sobject {
  // 🆔 Id that allows to distinguish it from other sobjects.
  string id = 1;
  // 🛠️ The plan for the element.
  Plan plan = 2;
}

// A port is an abstract location where a sobject should be connected.
message Port {
  // 🆔 Id of the sobject which will be the host of the port.
  string sobject_id = 1;
  // 🎛️ Parameters for the port.
  repeated Parameter parameters = 2;
  // An optional model of the other user of the port.
  Model user = 3;
}

// An connection can be used to connect two ports.
message Connection {
  // The connecting sobject. It is interchangable with the connected.
  Port connecting = 1;
  // The connected sobject. It is interchangable with the connecting.
  Port connected = 2;
}

// An assembly (tree) defines a subset of a layout that can be assembled unambiguously.
message Assembly{
  // The id of the sobject to place.
  string sobject_id = 1;
  // The parts of an assembly (tree) are again assemblies.
  repeated Assembly parts = 2;
}

// A layout (graph) is a plan for a set of sobjects and their connections between each other.
message Layout {
  // Sobjects (nodes) that are part of the layout (graph).
  repeated Sobject sobjects = 1;
  // Connections (edges) that are part of the layout (graph).
  repeated Connection connections = 2;
}

// A prototype acts as a template from which an element can be cloned.
message Prototype {
  // The hash of the plan used for the construction of the prototype.
  string plan_hash = 1;
  // Models of the prototype.
  repeated Model models = 2;
}

// An element is the atom of a design.
message Element {
  // The sobject id that was used to construct the element.
  string sobject_id = 1;
  // The hash of the plan for the prototype of the element.
  string prototype_plan_hash = 2;
  // The pose of the element instance.
  semio.geometry.v1.Pose pose = 3;
}

// 🏢 A design is an aggregation of elements (actually element occurances of prototypes).
message Design {
  repeated Prototype prototypes = 1;
  repeated Element elements = 2;
}

// A decision
// Multiple decisions: 🧬

// 🖧 A rule describes declaratively a layout and the layout after its modification. The rules on how to imperatively change such a layout need to be found by the transformation system.
message Rule {
  Plan plan = 1;
  Layout modified_context = 2;
}

// A rule strategy holds information on how modifications are applied.
message LayoutModificationStrategy {
  // The match count describes how often a layout modification should be applied. It beeing finite will make sure that the system always terminates. Make sure to set the threshold high enough.
  uint32 match_count = 1;
}
