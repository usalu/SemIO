syntax = "proto3";

package semio.model.v1;

option go_package = "github.com/usalu/semio/src/packages/go/model/v1";
option csharp_namespace = "Semio.Model.V1";

// A 3d point with x,y,z coordinates.
message Point {
  // x coordinate.
  double x = 1;
  // y coordinate
  double y = 2;
  // z coordinate
  double z = 3;
}

// Quaternions represent (here) (rotational) orientation. It can be interpreted as the view of an element.  
message Quaternion {
  double w = 1;
  double x = 2;
  double y = 3;
  double z = 4;
}

// A pose is a reference frame with a point of view (origin) and orientation (view).
message Pose {
  Point point_of_view = 1;
  Quaternion view = 2;
}

// A representation for an element. Basically a file with some semio specific metadata.
message Representation {
  // The body depends on the serialization format of the representation.
  bytes body = 1;
  // Encoding of the body
  Encoding encoding = 2;
  // Use the abbreviation of the platform. You can find that in the constants part of the package.
  FileType file_type = 3;
  // Native platform of representation
  Platform platform = 4;
  // A description of the representation for humans to understand what the purpose of this representation is.
  string description = 5;
  // Add a list of concepts that help filtering representations. This can be used for functional purpose (e.g. statical, energetical, ...) or for visualization purpose (e.g. volumetric,comic, , ...). 
  repeated string concepts = 6;
  // Level of detail allows to further define representation details. Like name this can be used either for visualization purpose (e.g. 200 (scale 1to200)) or functional purpose (e.g level of structural detail)
  // For architectural design it is recommended to choose the scale multiplier.
  // For BIM you might want to choose:
  // 100:Conceptual
  // 200:Approximate
  // 300:Precise
  // 400:Fabriaction
  // 500:Real 
  int64 lod = 7;
}

// Encoding of a byte array.
enum Encoding {
  ENCODING_TEXT_UFT8 = 0;
  ENCODING_TEXT_UFT16 = 1;
  ENCODING_TEXT_UFT32 = 2;
  ENCODING_TEXT_ASCII = 3;
  // Also ASCII but with further base 64 encoding of the text.
  ENCODING_TEXT_BASE64 = 4;
}

enum FileType {
  // Native serialization according platform. Use this only when it is none of the others.
  // Often files have a platform specific extension but if you open them in a text editor you can see that they are serialized in a standard format.
  FILETYPE_NATIVE = 0;
  FILETYPE_JSON = 1;
  FILETYPE_XML = 2;
  FILETYPE_YAML = 3;
  FILETYPE_TOML = 4;
  // https://www.iso.org/standard/63141.html
  FILETYPE_STEP = 5;
  // Python
  FILETYPE_PY = 6;
  FILETYPE_C = 7;
  // C++
  FILETYPE_CPP = 8;
  // C#
  FILETYPE_CSHARP = 9;
  // Golang
  FILETYPE_GO = 10;
  FILETYPE_RUST = 11;
}

// Platform. Constants are encoded with pattern LICENSE [3] + OWNERTYPE [2] + OWNERID [3] + PLATFORMID [2]
// LICENSE after https://spdx.org/licenses/: 
// 0:AGPL-3.0-or-later,
// 50:GPL-3.0+,51:GPL-3.0,52:GPL-2.0+,53:GPL-2.0
// 100:LGPL-3.0-or-later,101:LGPL-3.0-only
// 150:MIT,160:Apache-2.0,170:0BSD
// 214:Closed
// OWNER starting with OWNERTYPE:
// 0:INDIVIDUALS: 0:usalu,1:mrdoob,2:nortikin,3:hannobraun,4:ricosjp
// 1:COLLECTIVE: 0:ifcopenshell,1:cadquery,2:freecad,3:openscad,4:jscad
// 2:NONPROFIT: 0:buildingsmart
// 3:COMPANY: 0:mcneel,1:autodesk,2:nemetschek,3:esri
enum Platform {
  // https://github.com/usalu/semio
  PLATFORM_SEMIO = 0;
  // https://github.com/mrdoob/three.js/
  PLATFORM_THREE = 1000000100;
  // https://github.com/nortikin/sverchok
  PLATFORM_SVERCHOK = 500000200;
  // https://github.com/IfcOpenShell
  PLATFORM_IFCOPENSHELL = 1010100000;
  // https://github.com/CadQuery
  PLATFORM_CADQUERY = 1600100100;
  // https://github.com/FreeCAD
  PLATFORM_FREECAD = 530100200;
  // https://github.com/openscad
  PLATFORM_OPENSCAD = 530100300;
  // https://github.com/jscad
  PLATFORM_JSCAD = 1500100400;
  // https://github.com/hannobraun/Fornjot
  PLATFORM_Fornjot = 1700000300;
  // https://github.com/ricosjp/truck
  PLATFORM_TRUCK = 1500000400;
  // https://www.rhino3d.com/
  PLATFORM_RHINO = 2140300000;
  // https://www.grasshopper3d.com/
  PLATFORM_GRASSHOPPER = 2140300001;
  // https://www.autodesk.de/products/revit/
  PLATFORM_REVIT = 2140300100;
  // https://dynamobim.org/
  PLATFORM_DYNAMO = 2140300101;
}

// Instance information for an element.
message Sobject {
  // Id that allows to distinguish it from other sobjects.
  string id = 1;
  // The url of the element definition.
  string url = 2;
  // Parameters for the element.
  map<string,string> parameters = 3;
}

// The representation protocol determines what type of representation the attractor will see of the attracted in the attraction process.
enum RepresentationProtocol{
  // The attractor sees no representation of the attracted.
  REPRESENTATIONPROTOCOL_NONE = 0;
  // In the simple representation protocol everything is represented by a point.
  REPRESENTATIONPROTOCOL_SIMPLE = 1;
  // In the full representation protocol everything is represented by its native form where all information is available. This will most likely lead to strong coupled elements. Only use when absolutely necessary.
  REPRESENTATIONPROTOCOL_FULL = 2;
}

// An attraction participant participates in an attraction process.
message AttractionParticipant {
  // Id of participating sobject.
  string participant_id = 1;
  // The (rough) pose of the participating sobject. Note that in the attraction process it will most likely be displaced and adjusted.
  Pose pose = 2;
  // An optional representation of the participant.
  RepresentationProtocol representationProtocol = 3;
  // Optional port names to connect to. The hierarchy should matter
  repeated string ports = 4;
  // Optional parameters to bias the attraction.
  map<string,string> bias = 5;
}

// An attraction can be used to attract an attracted attraction participant to an attractor attraction participant.
message Attraction {
  // Id that allows to distinguish it from other attractions.
  string id = 1;
  // The attractor is expected to be the fixed sobject.
  AttractionParticipant attractor = 2;
  // The attracted is expected to be the flexible sobject that adjusts its point of view.
  AttractionParticipant attracted = 3;
}

// An attraction tree defines a possibly unambiguous subset of a layout.
message AttractionTree{
  // The id of the sobject to place.
  string sobject_id = 1;
  // An optional id of the attraction that is used to place this sobject. Only relevent when multiple attractions are defined from the same type.
  // Roots can't have that field as they have no parent.
  string attraction_id = 2;
  repeated AttractionTree children = 3;
}

// A layout strategy affects in which orders attractions are triggered.
enum LayoutStrategy {
  // A breadth first layout strategy will attract all neighbours first before these start to do the same with their neighbours.
  LAYOUTSTRATEGY_BREADTHFIRST = 0;
  // A depth first layout strategy will always prioritize to choose the neighbour of the neighbour first before the other neighbours of the root.
  LAYOUTSTRATEGY_DEPTHFIRST = 1;
}

// A layout (graph) is an assembly plan for a set of sobjects and their attractions between each other.
message Layout {
  // Sobjects (nodes) that are part of the layout (graph).
  repeated Sobject sobjects = 1;
  // Attractions (edges) that are part of the layout (graph).
  repeated Attraction attractions = 2;
  LayoutStrategy strategy = 3;
  // Optional attraction trees that can possibly unambiguously describe the layout order of sobjects.
  // Most of the time this field is only necissary due to elements that don't work well together in a general way.
  // Therefore if you can update the element definitions to be more robust, rather use your time for that.
  repeated AttractionTree attraction_trees = 4;
}

// An element is the atom of a design. It has several representations and a pose.
message Element {
  // The id of the sobject that was used to create the element is also the element id.
  string id = 1;
  repeated Representation representations = 2;
  // An optional human readable description of the element.
  string description = 3;
}

// An element occurance describes where an element occurs in the design.
message ElementOccurance{
  // Id of the element (occurance).
  string element_id = 1;
  // Pose of the element (occurance).
  Pose element_pose = 2;
}

// A design is an aggregation of elements.
message Design {
  repeated Element elements = 1;
  repeated ElementOccurance elementOccurances = 2;
}

// A layout modification describes declaratively a layout and the layout after its modification. The rules on how to imperatively change such a layout need to be found by the transformation system.
message LayoutModification {
  Layout context = 1;
  Layout modified_context = 2;
}

// A decision strategy holds information on how modifications are applied.
message LayoutModificationStrategy {
  // The match count describes how often a layout modification should be applied. It beeing finite will make sure that the system always terminates. Make sure to set the threshold high enough.
  int64 match_count = 1;
}

// A decision is a layout modification with a strategy on how to apply it to a new layout.
message Decision {
  LayoutModification modification = 1;
  LayoutModificationStrategy strategy = 2;
}
