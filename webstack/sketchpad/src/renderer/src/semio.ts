import cytoscape from 'cytoscape'
import { Matrix4, Quaternion, Vector3 } from 'three'
import {
    Point as TPoint,
    Vector as TVector,
    Plane as TPlane,
    Formation,
    FormationInput,
    Piece as TPiece,
    PieceInput,
    Port,
} from './semio.d'

export const TOLERANCE = 1e-5

// Generated by: https://the-guild.dev/graphql/codegen with "Schema Types"
// export type Maybe<T> = T | null
// export type InputMaybe<T> = Maybe<T>
// export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }
// export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> }
// export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> }
// export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never }
// export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never }
// /** All built-in and custom scalars, mapped to their actual values */
// export type Scalars = {
//     ID: { input: string; output: string; }
//     String: { input: string; output: string; }
//     Boolean: { input: boolean; output: boolean; }
//     Int: { input: number; output: number; }
//     Float: { input: number; output: number; }
//     /**
//      * The `DateTime` scalar type represents a DateTime
//      * value as specified by
//      * [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
//      */
//     DateTime: { input: any; output: any; }
// }

// export type Query = {
//     __typename?: 'Query'
//     loadLocalKit?: Maybe<LoadLocalKitResponse>
//     formationToSceneFromLocalKit?: Maybe<FormationToSceneFromLocalKitResponse>
// }


// export type QueryLoadLocalKitArgs = {
//     directory: Scalars['String']['input']
// }


// export type QueryFormationToSceneFromLocalKitArgs = {
//     directory: Scalars['String']['input']
//     formationIdInput: FormationIdInput
// }

// export type LoadLocalKitResponse = {
//     __typename?: 'LoadLocalKitResponse'
//     kit?: Maybe<Kit>
//     error?: Maybe<LoadLocalKitError>
// }

// /** üóÉÔ∏è A kit is a collection of types and formations. */
// export type Kit = {
//     __typename?: 'Kit'
//     name: Scalars['String']['output']
//     description: Scalars['String']['output']
//     icon: Scalars['String']['output']
//     createdAt: Scalars['DateTime']['output']
//     lastUpdateAt: Scalars['DateTime']['output']
//     url: Scalars['String']['output']
//     homepage: Scalars['String']['output']
//     types: Array<Type>
//     formations: Array<Formation>
// }

// /** üß© A type is a reusable element that can be connected with other types over ports. */
// export type Type = {
//     __typename?: 'Type'
//     name: Scalars['String']['output']
//     description: Scalars['String']['output']
//     icon: Scalars['String']['output']
//     variant: Scalars['String']['output']
//     unit: Scalars['String']['output']
//     createdAt: Scalars['DateTime']['output']
//     lastUpdateAt: Scalars['DateTime']['output']
//     kit?: Maybe<Kit>
//     representations: Array<Representation>
//     ports: Array<Port>
//     qualities: Array<Quality>
//     pieces: Array<Piece>
// }

// /** üíæ A representation is a link to a file that describes a type for a certain level of detail and tags. */
// export type Representation = {
//     __typename?: 'Representation'
//     url: Scalars['String']['output']
//     lod: Scalars['String']['output']
//     type?: Maybe<Type>
//     tags: Array<Scalars['String']['output']>
// }

// /** üîå A port is a conceptual connection point (with a direction) of a type. */
// export type Port = {
//     __typename?: 'Port'
//     type?: Maybe<Type>
//     locators: Array<Locator>
//     connecteds: Array<Connection>
//     connectings: Array<Connection>
//     id: Scalars['String']['output']
//     point: Point
//     direction: Vector
//     plane: Plane
// }

// /** üó∫Ô∏è A locator is meta-data for grouping ports. */
// export type Locator = {
//     __typename?: 'Locator'
//     group: Scalars['String']['output']
//     subgroup: Scalars['String']['output']
//     port?: Maybe<Port>
// }

// /** üñáÔ∏è A connection between two pieces of a formation. */
// export type Connection = {
//     __typename?: 'Connection'
//     offset: Scalars['Float']['output']
//     rotation: Scalars['Float']['output']
//     formation?: Maybe<Formation>
//     connected: Side
//     connecting: Side
// }

// /** üèôÔ∏è A formation is a collection of pieces that are connected. */
// export type Formation = {
//     __typename?: 'Formation'
//     name: Scalars['String']['output']
//     description: Scalars['String']['output']
//     icon: Scalars['String']['output']
//     variant: Scalars['String']['output']
//     unit: Scalars['String']['output']
//     createdAt: Scalars['DateTime']['output']
//     lastUpdateAt: Scalars['DateTime']['output']
//     kit?: Maybe<Kit>
//     pieces: Array<Piece>
//     connections: Array<Connection>
//     qualities: Array<Quality>
// }

// /** ‚≠ï A piece is a 3d-instance of a type in a formation. */
// export type Piece = {
//     __typename?: 'Piece'
//     type?: Maybe<Type>
//     formation?: Maybe<Formation>
//     connectings: Array<Connection>
//     connecteds: Array<Connection>
//     id: Scalars['String']['output']
//     root?: Maybe<PieceRoot>
//     diagram: PieceDiagram
// }

// /** üå± The root information of a piece. */
// export type PieceRoot = {
//     __typename?: 'PieceRoot'
//     plane: Plane
// }

// /** ‚ó≥ A plane is an origin (point) and an orientation (x-axis and y-axis). */
// export type Plane = {
//     __typename?: 'Plane'
//     origin: Point
//     xAxis: Vector
//     yAxis: Vector
// }

// /** ‚úñÔ∏è A 3d-point (xyz) of floating point numbers. */
// export type Point = {
//     __typename?: 'Point'
//     x: Scalars['Float']['output']
//     y: Scalars['Float']['output']
//     z: Scalars['Float']['output']
// }

// /** ‚û°Ô∏è A 3d-vector (xyz) of floating point numbers. */
// export type Vector = {
//     __typename?: 'Vector'
//     x: Scalars['Float']['output']
//     y: Scalars['Float']['output']
//     z: Scalars['Float']['output']
// }

// /** ‚úèÔ∏è The diagram information of a piece. */
// export type PieceDiagram = {
//     __typename?: 'PieceDiagram'
//     point: ScreenPoint
// }

// /** üì∫ A 2d-point (xy) of integers in screen coordinate system. */
// export type ScreenPoint = {
//     __typename?: 'ScreenPoint'
//     x: Scalars['Int']['output']
//     y: Scalars['Int']['output']
// }

// /** üìè A quality is meta-data for decision making. */
// export type Quality = {
//     __typename?: 'Quality'
//     name: Scalars['String']['output']
//     value: Scalars['String']['output']
//     unit: Scalars['String']['output']
//     definition: Scalars['String']['output']
//     type?: Maybe<Type>
//     formation?: Maybe<Formation>
// }

// /** üß± A side of a piece in a connection. */
// export type Side = {
//     __typename?: 'Side'
//     piece: SidePiece
// }

// /** ‚≠ï The piece information of a side. A piece is identified by an id (emtpy=default)). */
// export type SidePiece = {
//     __typename?: 'SidePiece'
//     id: Scalars['String']['output']
//     type: SidePieceType
// }

// /** üß© The type information of a piece of a side. */
// export type SidePieceType = {
//     __typename?: 'SidePieceType'
//     port?: Maybe<Port>
// }

// export enum LoadLocalKitError {
//     DirectoryDoesNotExist = 'DIRECTORY_DOES_NOT_EXIST',
//     DirectoryIsNotADirectory = 'DIRECTORY_IS_NOT_A_DIRECTORY',
//     DirectoryHasNoKit = 'DIRECTORY_HAS_NO_KIT',
//     NoPermissionToReadKit = 'NO_PERMISSION_TO_READ_KIT'
// }

// export type FormationToSceneFromLocalKitResponse = {
//     __typename?: 'FormationToSceneFromLocalKitResponse'
//     scene?: Maybe<Scene>
//     error?: Maybe<FormationToSceneFromLocalKitResponseError>
// }

// /** üåÜ A scene is a collection of objects. */
// export type Scene = {
//     __typename?: 'Scene'
//     objects: Array<Maybe<Object>>
//     formation?: Maybe<Formation>
// }

// /** üóø An object is a piece with a plane and a parent object (unless the piece is a root). */
// export type Object = {
//     __typename?: 'Object'
//     plane: Plane
//     piece?: Maybe<Piece>
//     parent?: Maybe<Object>
// }

// export type FormationToSceneFromLocalKitResponseError = {
//     __typename?: 'FormationToSceneFromLocalKitResponseError'
//     code: FormationToSceneFromLocalKitResponseErrorCode
//     message?: Maybe<Scalars['String']['output']>
// }

// export enum FormationToSceneFromLocalKitResponseErrorCode {
//     DirectoryDoesNotExist = 'DIRECTORY_DOES_NOT_EXIST',
//     DirectoryIsNotADirectory = 'DIRECTORY_IS_NOT_A_DIRECTORY',
//     DirectoryHasNoKit = 'DIRECTORY_HAS_NO_KIT',
//     NoPermissionToReadKit = 'NO_PERMISSION_TO_READ_KIT',
//     FormationDoesNotExist = 'FORMATION_DOES_NOT_EXIST'
// }

// /** üèôÔ∏è A formation is identified by a name and optional variant. */
// export type FormationIdInput = {
//     name: Scalars['String']['input']
//     variant?: InputMaybe<Scalars['String']['input']>
// }

// export type Mutation = {
//     __typename?: 'Mutation'
//     createLocalKit?: Maybe<CreateLocalKitMutation>
//     updateLocalKitMetadata?: Maybe<UpdateLocalKitMetadataMutation>
//     deleteLocalKit?: Maybe<DeleteLocalKitMutation>
//     addTypeToLocalKit?: Maybe<AddTypeToLocalKitMutation>
//     removeTypeFromLocalKit?: Maybe<RemoveTypeFromLocalKitMutation>
//     addFormationToLocalKit?: Maybe<AddFormationToLocalKitMutation>
//     removeFormationFromLocalKit?: Maybe<RemoveFormationFromLocalKitMutation>
// }


// export type MutationCreateLocalKitArgs = {
//     directory: Scalars['String']['input']
//     kitInput: KitInput
// }


// export type MutationUpdateLocalKitMetadataArgs = {
//     directory: Scalars['String']['input']
//     kitMetadataInput: KitMetadataInput
// }


// export type MutationDeleteLocalKitArgs = {
//     directory: Scalars['String']['input']
// }


// export type MutationAddTypeToLocalKitArgs = {
//     directory: Scalars['String']['input']
//     typeInput: TypeInput
// }


// export type MutationRemoveTypeFromLocalKitArgs = {
//     directory: Scalars['String']['input']
//     typeId: TypeIdInput
// }


// export type MutationAddFormationToLocalKitArgs = {
//     directory: Scalars['String']['input']
//     formationInput: FormationInput
// }


// export type MutationRemoveFormationFromLocalKitArgs = {
//     directory: Scalars['String']['input']
//     formationId: FormationIdInput
// }

// export type CreateLocalKitMutation = {
//     __typename?: 'CreateLocalKitMutation'
//     kit?: Maybe<Kit>
//     error?: Maybe<CreateLocalKitError>
// }

// export type CreateLocalKitError = {
//     __typename?: 'CreateLocalKitError'
//     code: CreateLocalKitErrorCode
//     message?: Maybe<Scalars['String']['output']>
// }

// export enum CreateLocalKitErrorCode {
//     DirectoryIsNotADirectory = 'DIRECTORY_IS_NOT_A_DIRECTORY',
//     DirectoryAlreadyContainsAKit = 'DIRECTORY_ALREADY_CONTAINS_A_KIT',
//     NoPermissionToCreateDirectory = 'NO_PERMISSION_TO_CREATE_DIRECTORY',
//     NoPermissionToCreateKit = 'NO_PERMISSION_TO_CREATE_KIT',
//     KitInputIsInvalid = 'KIT_INPUT_IS_INVALID'
// }

// /** üóÉÔ∏è A kit is a collection of types and formations. */
// export type KitInput = {
//     name: Scalars['String']['input']
//     description?: InputMaybe<Scalars['String']['input']>
//     icon?: InputMaybe<Scalars['String']['input']>
//     url?: InputMaybe<Scalars['String']['input']>
//     homepage?: InputMaybe<Scalars['String']['input']>
//     types?: InputMaybe<Array<TypeInput>>
//     formations?: InputMaybe<Array<FormationInput>>
// }

// /** üß© A type is a reusable element that can be connected with other types over ports. */
// export type TypeInput = {
//     name: Scalars['String']['input']
//     description?: InputMaybe<Scalars['String']['input']>
//     icon?: InputMaybe<Scalars['String']['input']>
//     variant?: InputMaybe<Scalars['String']['input']>
//     unit: Scalars['String']['input']
//     representations: Array<RepresentationInput>
//     ports: Array<PortInput>
//     qualities?: InputMaybe<Array<QualityInput>>
// }

// /** üíæ A representation is a link to a file that describes a type for a certain level of detail and tags. */
// export type RepresentationInput = {
//     url: Scalars['String']['input']
//     lod?: InputMaybe<Scalars['String']['input']>
//     tags?: InputMaybe<Array<Scalars['String']['input']>>
// }

// /** üîå A port is a conceptual connection point (with a direction) of a type. */
// export type PortInput = {
//     id?: InputMaybe<Scalars['String']['input']>
//     point: PointInput
//     direction: VectorInput
//     locators?: InputMaybe<Array<LocatorInput>>
// }

// /** ‚úñÔ∏è A 3d-point (xyz) of floating point numbers. */
// export type PointInput = {
//     x?: InputMaybe<Scalars['Float']['input']>
//     y?: InputMaybe<Scalars['Float']['input']>
//     z?: InputMaybe<Scalars['Float']['input']>
// }

// /** ‚û°Ô∏è A 3d-vector (xyz) of floating point numbers. */
// export type VectorInput = {
//     x?: InputMaybe<Scalars['Float']['input']>
//     y?: InputMaybe<Scalars['Float']['input']>
//     z?: InputMaybe<Scalars['Float']['input']>
// }

// /** üó∫Ô∏è A locator is meta-data for grouping ports. */
// export type LocatorInput = {
//     group: Scalars['String']['input']
//     subgroup?: InputMaybe<Scalars['String']['input']>
// }

// /** üìè A quality is meta-data for decision making. */
// export type QualityInput = {
//     name: Scalars['String']['input']
//     value?: InputMaybe<Scalars['String']['input']>
//     unit?: InputMaybe<Scalars['String']['input']>
//     definition?: InputMaybe<Scalars['String']['input']>
// }

// /** üèôÔ∏è A formation is a collection of pieces that are connected. */
// export type FormationInput = {
//     name: Scalars['String']['input']
//     description?: InputMaybe<Scalars['String']['input']>
//     icon?: InputMaybe<Scalars['String']['input']>
//     variant?: InputMaybe<Scalars['String']['input']>
//     unit: Scalars['String']['input']
//     pieces: Array<PieceInput>
//     connections: Array<ConnectionInput>
//     qualities?: InputMaybe<Array<QualityInput>>
// }

// /** ‚≠ï A piece is a 3d-instance of a type in a formation. */
// export type PieceInput = {
//     id: Scalars['String']['input']
//     type: TypeIdInput
//     root?: InputMaybe<PieceRootInput>
//     diagram: PieceDiagramInput
// }

// /** üß© A type is identified by a name and variant (empty=default). */
// export type TypeIdInput = {
//     name: Scalars['String']['input']
//     variant?: InputMaybe<Scalars['String']['input']>
// }

// /** üå± The root information of a piece. */
// export type PieceRootInput = {
//     plane: PlaneInput
// }

// /** ‚ó≥ A plane is an origin (point) and an orientation (x-axis and y-axis). */
// export type PlaneInput = {
//     origin: PointInput
//     xAxis: VectorInput
//     yAxis: VectorInput
// }

// /** ‚úèÔ∏è The diagram information of a piece. */
// export type PieceDiagramInput = {
//     point: ScreenPointInput
// }

// /** üì∫ A 2d-point (xy) of integers in screen coordinate system. */
// export type ScreenPointInput = {
//     x?: InputMaybe<Scalars['Int']['input']>
//     y?: InputMaybe<Scalars['Int']['input']>
// }

// /** üñáÔ∏è A connection between two pieces of a formation. */
// export type ConnectionInput = {
//     connecting: SideInput
//     connected: SideInput
//     offset?: InputMaybe<Scalars['Float']['input']>
//     rotation?: InputMaybe<Scalars['Float']['input']>
// }

// /** üß± A side of a piece in a connection. */
// export type SideInput = {
//     piece: SidePieceInput
// }

// /** ‚≠ï The piece information of a side. A piece is identified by an id (emtpy=default)). */
// export type SidePieceInput = {
//     id: Scalars['String']['input']
//     type?: InputMaybe<SidePieceTypeInput>
// }

// /** üß© The type information of a piece of a side. */
// export type SidePieceTypeInput = {
//     port?: InputMaybe<PortIdInput>
// }

// /** üîå A port is identified by an id (emtpy=default)). */
// export type PortIdInput = {
//     id?: InputMaybe<Scalars['String']['input']>
// }

// export type UpdateLocalKitMetadataMutation = {
//     __typename?: 'UpdateLocalKitMetadataMutation'
//     kit?: Maybe<Kit>
//     error?: Maybe<UpdateLocalKitMetadataError>
// }

// export type UpdateLocalKitMetadataError = {
//     __typename?: 'UpdateLocalKitMetadataError'
//     code: UpdateLocalKitMetadataErrorCode
//     message?: Maybe<Scalars['String']['output']>
// }

// export enum UpdateLocalKitMetadataErrorCode {
//     DirectoryDoesNotExist = 'DIRECTORY_DOES_NOT_EXIST',
//     DirectoryIsNotADirectory = 'DIRECTORY_IS_NOT_A_DIRECTORY',
//     DirectoryHasNoKit = 'DIRECTORY_HAS_NO_KIT',
//     NoPermissionToUpdateKit = 'NO_PERMISSION_TO_UPDATE_KIT',
//     KitMetadataIsInvalid = 'KIT_METADATA_IS_INVALID'
// }

// /** üóÉÔ∏è Meta-data of a kit. */
// export type KitMetadataInput = {
//     name?: InputMaybe<Scalars['String']['input']>
//     description?: InputMaybe<Scalars['String']['input']>
//     icon?: InputMaybe<Scalars['String']['input']>
//     url?: InputMaybe<Scalars['String']['input']>
//     homepage?: InputMaybe<Scalars['String']['input']>
// }

// export type DeleteLocalKitMutation = {
//     __typename?: 'DeleteLocalKitMutation'
//     error?: Maybe<DeleteLocalKitError>
// }

// export enum DeleteLocalKitError {
//     DirectoryDoesNotExist = 'DIRECTORY_DOES_NOT_EXIST',
//     DirectoryHasNoKit = 'DIRECTORY_HAS_NO_KIT',
//     NoPermissionToDeleteKit = 'NO_PERMISSION_TO_DELETE_KIT'
// }

// export type AddTypeToLocalKitMutation = {
//     __typename?: 'AddTypeToLocalKitMutation'
//     type?: Maybe<Type>
//     error?: Maybe<AddTypeToLocalKitError>
// }

// export type AddTypeToLocalKitError = {
//     __typename?: 'AddTypeToLocalKitError'
//     code: AddTypeToLocalKitErrorCode
//     message?: Maybe<Scalars['String']['output']>
// }

// export enum AddTypeToLocalKitErrorCode {
//     DirectoryDoesNotExist = 'DIRECTORY_DOES_NOT_EXIST',
//     DirectoryIsNotADirectory = 'DIRECTORY_IS_NOT_A_DIRECTORY',
//     DirectoryHasNoKit = 'DIRECTORY_HAS_NO_KIT',
//     NoPermissionToModifyKit = 'NO_PERMISSION_TO_MODIFY_KIT',
//     TypeInputIsInvalid = 'TYPE_INPUT_IS_INVALID'
// }

// export type RemoveTypeFromLocalKitMutation = {
//     __typename?: 'RemoveTypeFromLocalKitMutation'
//     error?: Maybe<RemoveTypeFromLocalKitError>
// }

// export type RemoveTypeFromLocalKitError = {
//     __typename?: 'RemoveTypeFromLocalKitError'
//     code: RemoveTypeFromLocalKitErrorCode
//     message?: Maybe<Scalars['String']['output']>
// }

// export enum RemoveTypeFromLocalKitErrorCode {
//     DirectoryDoesNotExist = 'DIRECTORY_DOES_NOT_EXIST',
//     DirectoryIsNotADirectory = 'DIRECTORY_IS_NOT_A_DIRECTORY',
//     DirectoryHasNoKit = 'DIRECTORY_HAS_NO_KIT',
//     NoPermissionToModifyKit = 'NO_PERMISSION_TO_MODIFY_KIT',
//     TypeDoesNotExist = 'TYPE_DOES_NOT_EXIST',
//     FormationDependsOnType = 'FORMATION_DEPENDS_ON_TYPE'
// }

// export type AddFormationToLocalKitMutation = {
//     __typename?: 'AddFormationToLocalKitMutation'
//     formation?: Maybe<Formation>
//     error?: Maybe<AddFormationToLocalKitError>
// }

// export type AddFormationToLocalKitError = {
//     __typename?: 'AddFormationToLocalKitError'
//     code: AddFormationToLocalKitErrorCode
//     message?: Maybe<Scalars['String']['output']>
// }

// export enum AddFormationToLocalKitErrorCode {
//     DirectoryDoesNotExist = 'DIRECTORY_DOES_NOT_EXIST',
//     DirectoryIsNotADirectory = 'DIRECTORY_IS_NOT_A_DIRECTORY',
//     DirectoryHasNoKit = 'DIRECTORY_HAS_NO_KIT',
//     NoPermissionToModifyKit = 'NO_PERMISSION_TO_MODIFY_KIT',
//     FormationInputIsInvalid = 'FORMATION_INPUT_IS_INVALID'
// }

// export type RemoveFormationFromLocalKitMutation = {
//     __typename?: 'RemoveFormationFromLocalKitMutation'
//     error?: Maybe<RemoveFormationFromLocalKitError>
// }

// export type RemoveFormationFromLocalKitError = {
//     __typename?: 'RemoveFormationFromLocalKitError'
//     code: RemoveFormationFromLocalKitErrorCode
//     message?: Maybe<Scalars['String']['output']>
// }

// export enum RemoveFormationFromLocalKitErrorCode {
//     DirectoryDoesNotExist = 'DIRECTORY_DOES_NOT_EXIST',
//     DirectoryIsNotADirectory = 'DIRECTORY_IS_NOT_A_DIRECTORY',
//     DirectoryHasNoKit = 'DIRECTORY_HAS_NO_KIT',
//     NoPermissionToModifyKit = 'NO_PERMISSION_TO_MODIFY_KIT',
//     FormationDoesNotExist = 'FORMATION_DOES_NOT_EXIST'
// }

export enum CoordinateSystem {
    SEMIO = 'SEMIO',
    THREE = 'THREE',
}

export const radians = (degrees: number): number => {
    return degrees * (Math.PI / 180)
}

export const degrees = (radians: number): number => {
    return radians * (180 / Math.PI)
}

export class Point extends Vector3 {

    constructor(x: number = 0, y: number = 0, z: number = 0) {
        super(x, y, z)
    }

    [n: number]: number

    *[Symbol.iterator](): Iterator<number> {
        yield this.x
        yield this.y
        yield this.z
    }

    get 0(): number { return this.x }
    get 1(): number { return this.y }
    get 2(): number { return this.z }

    isCloseTo(other: Point | Vector | number, tol: number = TOLERANCE): boolean {
        if (typeof other === 'number') {
            return (
                Math.abs(this.x - other) < tol &&
                Math.abs(this.y - other) < tol &&
                Math.abs(this.z - other) < tol
            )
        } else if (other instanceof Vector) {
            return this.isCloseTo(other.toPoint(), tol)
        } else {
            return (
                Math.abs(this.x - other.x) < tol &&
                Math.abs(this.y - other.y) < tol &&
                Math.abs(this.z - other.z) < tol
            )
        }
    }

    toVector(): Vector { return new Vector(this.x, this.y, this.z) }

    static fromVector(vector: Vector): Point { return new Point(vector.x, vector.y, vector.z) }

    static parse(object: Point | TPoint | string | null | undefined): Point {
        if (object === undefined || object === null) {
            return new Point()
        }
        if (object instanceof Point) {
            return object
        }
        if (typeof object === 'string') {
            const { x, y, z } = JSON.parse(object)
            return new Point(x, y, z)
        }
        return new Point(object.x, object.y, object.z)
    }
}

export class Vector extends Vector3 {

    constructor(x: number = 0, y: number = 0, z: number = 0) {
        super(x, y, z)
    }

    [n: number]: number

    *[Symbol.iterator](): Iterator<number> {
        yield this.x
        yield this.y
        yield this.z
    }

    get 0(): number { return this.x }
    get 1(): number { return this.y }
    get 2(): number { return this.z }

    sqrt(): Vector {
        return new Vector(Math.sqrt(this.x), Math.sqrt(this.y), Math.sqrt(this.z))
    }

    sign(): Vector {
        return new Vector(Math.sign(this.x), Math.sign(this.y), Math.sign(this.z))
    }

    isCloseTo(other: Vector | Point | number, tol: number = TOLERANCE): boolean {
        if (typeof other === 'number') {
            return (
                Math.abs(this.x - other) < tol &&
                Math.abs(this.y - other) < tol &&
                Math.abs(this.z - other) < tol
            )
        } else if (other instanceof Point) {
            return this.isCloseTo(other.toVector(), tol)
        } else {
            return (
                Math.abs(this.x - other.x) < tol &&
                Math.abs(this.y - other.y) < tol &&
                Math.abs(this.z - other.z) < tol
            )
        }
    }

    isZero(tol: number = TOLERANCE): boolean {
        return this.isCloseTo(new Vector(), tol)
    }

    toPoint(): Point {
        return new Point(this.x, this.y, this.z)
    }

    toTransform(): Transform { return Transform.fromTranslation(this) }

    static X(): Vector {
        return new Vector(1, 0, 0)
    }

    static Y(): Vector {
        return new Vector(0, 1, 0)
    }

    static Z(): Vector {
        return new Vector(0, 0, 1)
    }

    static parse(object: Vector | TVector | string | null | undefined): Vector {
        if (object === undefined || object === null) {
            return new Vector()
        }
        if (object instanceof Vector) {
            return object
        }
        if (typeof object === 'string') {
            const { x, y, z } = JSON.parse(object)
            return new Vector(x, y, z)
        }
        return new Vector(object.x, object.y, object.z)
    }
}

export class Plane {
    origin: Point
    xAxis: Vector
    yAxis: Vector

    constructor(origin?: Point, xAxis?: Vector, yAxis?: Vector) {
        this.origin = origin ?? new Point()
        this.xAxis = xAxis ?? Vector.X()
        this.yAxis = yAxis ?? Vector.Y()
        if (this.xAxis.length() - 1 > TOLERANCE) {
            throw new Error("The x-axis must be normalized.")
        }
        if (this.yAxis.length() - 1 > TOLERANCE) {
            throw new Error("The y-axis must be normalized.")
        }
        if (Math.abs(this.xAxis.dot(this.yAxis)) > TOLERANCE) {
            throw new Error("The x-axis and y-axis must be orthogonal.")
        }
    }

    get zAxis(): Vector {
        return new Vector().crossVectors(this.xAxis, this.yAxis)
    }

    isCloseTo(other: Plane, tol: number = TOLERANCE): boolean {
        return (
            this.origin.isCloseTo(other.origin, tol) &&
            this.xAxis.isCloseTo(other.xAxis, tol) &&
            this.yAxis.isCloseTo(other.yAxis, tol)
        )
    }

    transform(transform: Transform): Plane {
        return transform.transformPlane(this)
    }

    toTransform(): Transform {
        return Transform.fromPlane(this)
    }

    toThree(): Plane {
        return this.transform(semioToThreeRotation())
    }

    toSemio(): Plane {
        return this.transform(threeToSemioRotation())
    }

    static XY(): Plane {
        return new Plane(new Point(), Vector.X(), Vector.Y())
    }

    static fromYAxis(yAxis: Vector, theta: number = 0, origin?: Point): Plane {
        if (yAxis.length() - 1 > TOLERANCE) {
            throw new Error("The yAxis must be normalized.")
        }
        const orientation = Transform.fromDirections(Vector.Y(), yAxis)
        const rotation = Transform.fromAngle(yAxis, theta)
        const xAxis = Vector.X().applyMatrix4(rotation.multiply(orientation))
        return new Plane(origin ?? new Point(), xAxis, yAxis)
    }

    static parse(object?: Plane | TPlane | string | null | undefined): Plane {
        if (object === undefined || object === null) {
            return new Plane()
        }
        if (object instanceof Plane) {
            return object
        }
        if (typeof object === 'string') {
            const { origin, xAxis, yAxis } = JSON.parse(object)
            return new Plane(Point.parse(origin), Vector.parse(xAxis), Vector.parse(yAxis))
        }
        return new Plane(Point.parse(object.origin), Vector.parse(object.xAxis), Vector.parse(object.yAxis))
    }
}

export class Rotation {
    axis: Vector
    angle: number

    constructor(axis?: Vector, angle: number = 0) {
        this.axis = axis ?? Vector.Z()
        this.angle = angle
    }

    toTransform(): Transform {
        return Transform.fromRotation(this)
    }

    toJSON(): object | null {
        return this.angle === 0 ? null : {
            axis: this.axis,
            angle: this.angle
        }
    }
}

export class Transform extends Matrix4 {
    constructor() {
        super()
    }
    get rotation(): Rotation {
        //https://github.com/dfki-ric/pytransform3d/blob/c45e817c4a7960108afe9f5259542c8376c0e89a/pytransform3d/rotations/_conversions.py#L1719
        const rotationMatrix = new Matrix4()
        rotationMatrix.extractRotation(this)
        const trace = rotationMatrix.elements[0] + rotationMatrix.elements[5] + rotationMatrix.elements[10]
        const cosAngle = (trace - 1) / 2
        const angle = Math.acos(Math.min(Math.max(-1, cosAngle), 1))
        if (angle === 0) return new Rotation()
        const axisUnnormalized = new Vector(
            rotationMatrix[6] - rotationMatrix[9],
            rotationMatrix[8] - rotationMatrix[2],
            rotationMatrix[1] - rotationMatrix[4]
        )
        let axis: Vector
        if (Math.abs(angle - Math.PI) < 1e-4) {
            const clampedDiagonal = new Vector(rotationMatrix[0], rotationMatrix[5], rotationMatrix[10]).clampScalar(-1, 1)
            const eeTDiag = clampedDiagonal.clone().addScalar(1).multiplyScalar(0.5)
            const signs = axisUnnormalized.clone().sign()
            const unitizedSigns = new Vector(signs.x || 1, signs.y || 1, signs.z || 1)
            axis = eeTDiag.sqrt().multiply(unitizedSigns)
        } else {
            axis = axisUnnormalized
        }
        const normalizedAxis = axis.normalize()
        return new Rotation(normalizedAxis, degrees(angle))
    }

    get translation(): Vector {
        const translation = new Vector()
        this.decompose(translation, new Quaternion(), new Vector())
        return translation
    }

    clone(): Transform {
        return new Transform().copy(this);
    }

    after(before: Transform): Transform {
        return new Transform().multiplyMatrices(before, this)
    }

    transformPoint(point: Point): Point {
        const transformedPoint = point.clone().applyMatrix4(this)
        return new Point(transformedPoint.x, transformedPoint.y, transformedPoint.z)
    }

    transformVector(vector: Vector): Vector {
        const transformedVector = vector.clone().applyMatrix4(this)
        return new Vector(transformedVector.x, transformedVector.y, transformedVector.z)
    }

    transformPlane(plane: Plane): Plane {
        const planeTransform = Transform.fromPlane(plane)
        const planeTransformed = planeTransform.after(this.clone())
        return planeTransformed.toPlane()
    }

    transform(geometry: Point | Vector | Plane): Point | Vector | Plane {
        if (geometry instanceof Point) {
            return this.transformPoint(geometry)
        } else if (geometry instanceof Vector) {
            return this.transformVector(geometry)
        } else if (geometry instanceof Plane) {
            return this.transformPlane(geometry)
        } else {
            throw new Error("Not implemented")
        }
    }

    static fromTranslation(vector: Vector): Transform {
        return new Transform().makeTranslation(vector.x, vector.y, vector.z)
    }

    static fromRotation(rotation: Rotation): Transform {
        return new Transform().makeRotationAxis(rotation.axis, radians(rotation.angle))
    }

    static fromPlane(plane: Plane): Transform {
        return new Transform().makeBasis(plane.xAxis, plane.yAxis, plane.zAxis)
            .setPosition(plane.origin)
    }

    static fromAngle(axis: Vector, angle: number): Transform {
        return new Transform().makeRotationAxis(axis, radians(angle))
    }

    static fromDirections(startDirection: Vector, endDirection: Vector): Transform {
        if (startDirection.isCloseTo(endDirection)) {
            return new Transform()
        }
        const axisAngle = new Vector3().crossVectors(startDirection, endDirection)
        return new Transform().makeRotationAxis(axisAngle.normalize(), startDirection.angleTo(endDirection))
    }

    toPlane(): Plane {
        const origin = new Point(this[12], this[13], this[14])
        const xAxis = new Vector(this[0], this[1], this[2])
        const yAxis = new Vector(this[4], this[5], this[6])
        return new Plane(origin, xAxis, yAxis)
    }

    toJSON(): object {
        return {
            rotation: this.rotation,
            translation: this.translation.isZero ? null : this.translation
        }
    }

    static parse(object: Transform | string | null | undefined): Transform {
        if (object === undefined || object === null) {
            return new Transform()
        }
        if (object instanceof Transform) {
            return object
        }
        if (typeof object === 'string') {
            const { rotation, translation } = JSON.parse(object)
            return new Transform().makeRotationAxis(Vector.parse(rotation.axis), radians(rotation.angle)).setPosition(Vector.parse(translation))
        }
        return new Transform().makeRotationAxis(Vector.parse(object.rotation.axis), radians(object.rotation.angle)).setPosition(Vector.parse(object.translation))
    }

}


export const semioToThreeRotation = (): Transform => {
    return new Transform().set(
        1, 0, 0, 0,
        0, 0, 1, 0,
        0, -1, 0, 0,
        0, 0, 0, 1)
}

export const threeToSemioRotation = (): Transform => {
    return new Transform().set(
        1, 0, 0, 0,
        0, 0, -1, 0,
        0, 1, 0, 0,
        0, 0, 0, 1)
}


class Hierarchy {
    piece: Piece | PieceInput
    transform: Transform
    children: Hierarchy[]

    constructor(piece: Piece | PieceInput, transform?: Transform | null | undefined, children?: Hierarchy[] | null | undefined) {
        this.piece = piece
        this.transform = transform ?? new Transform()
        this.children = children ?? []
    }
}

export default Hierarchy;

// Reference in Python:
// def formationToHierarchies(formation: Formation) -> List[Hierarchy]:
//     nodes = list((piece.localId, {"piece": piece}) for piece in formation.pieces)
//     edges = (
//         (
//             connection.connecting.piece.id,
//             connection.connected.piece.id,
//             {"connection": connection},
//         )
//         for connection in formation.connections
//     )
//     graph = Graph()
//     graph.add_nodes_from(nodes)
//     graph.add_edges_from(edges)
//     hierarchies = []
//     for componentGenerator in connected_components(graph):
//         component = graph.subgraph(componentGenerator)
//         try:
//             root = [
//                 node for node in component.nodes() if graph.nodes[node]["piece"].root
//             ][0]
//         except IndexError:
//             root = next(iter(component.nodes))
//         rootHierarchy = Hierarchy(
//             piece=graph.nodes[root]["piece"],
//             transform=Transform(),
//             children=[],
//         )
//         component.nodes[root]["hierarchy"] = rootHierarchy
//         for parent, child in bfs_tree(component, source=root).edges():
//             connection = component[parent][child]["connection"]
//             connectedIsParent = connection.connected.piece.id == parent
//             parentPort = connection.connected.piece.type.port if connectedIsParent else connection.connecting.piece.type.port
//             childPort = connection.connecting.piece.type.port if connectedIsParent else connection.connected.piece.type.port
//             orient = Transform.fromDirections(childPort.direction.revert(), parentPort.direction)
//             rotation = orient
//             if connection.rotation != 0.0:
//                 rotate = Transform.fromAngle(parentPort.direction, connection.rotation)
//                 rotation = rotate.after(orient)
//             centerConnecting = childPort.point.toVector().revert().toTransform()
//             moveToConnected = parentPort.point.toVector().toTransform()
//             transform = rotation.after(centerConnecting)
//             if connection.offset != 0.0:
//                 offset = parentPort.direction.amplify(connection.offset).toTransform()
//                 transform = offset.after(transform)
//             transform = moveToConnected.after(transform)
//             hierarchy = Hierarchy(
//                 piece=component.nodes[child]["piece"],
//                 transform=transform,
//                 children=[],
//             )
//             component.nodes[child]["hierarchy"] = hierarchy
//             component.nodes[parent]["hierarchy"].children.append(hierarchy)
//         hierarchies.append(rootHierarchy)
//     return hierarchies
export const formationToHierarchies = (
    formation: Formation | FormationInput,
    ports: Map<string, Map<string, Map<string, Port>>> // typeName -> typeVariant -> portId -> port
): Hierarchy[] => {
    if (formation.pieces.length === 0) return []
    const cy = cytoscape({
        elements: {
            nodes: formation.pieces.map((piece) => ({
                data: { id: piece.id, label: piece.id }
            })),
            edges: formation.connections.map((connection) => ({
                data: {
                    id: `${connection.connecting.piece.id}-${connection.connected.piece.id}`,
                    source: connection.connected.piece.id,
                    target: connection.connecting.piece.id
                }
            }))
        }
    })
    const hierarchies: Hierarchy[] = []
    const components = cy.elements().components()
    components.forEach((component) => {
        const roots = component
            .nodes()
            .filter((node) => formation.pieces.find((p) => p.id === node.id()).root)
        const root = roots.length === 0 ? component.nodes()[0] : roots[0]
        const rootPiece = formation.pieces.find((p) => p.id === root.id())
        const rootHierarchy = new Hierarchy(rootPiece)
        hierarchies.push(rootHierarchy)
        const pieceIdToHierarchy: { [key: string]: Hierarchy } = {}
        pieceIdToHierarchy[rootHierarchy.piece.id] = rootHierarchy
        cy.elements().bfs(
            {
                root,
                visit: (v, e, u, i, depth) => {
                    if (depth === 0) return
                    const parentId = u.id()
                    const childId = v.id()
                    const connection = formation.connections.find(
                        (connection) =>
                            connection.connected.piece.id === e.source().id() &&
                            connection.connecting.piece.id === e.target().id()
                    )
                    const connectedIsParent = connection.connected.piece.id === parentId
                    const parentPiece = formation.pieces.find((p) => p.id === parentId)
                    const childPiece = formation.pieces.find((p) => p.id === childId)
                    const parentPortId = connectedIsParent
                        ? connection.connected.piece?.type.port?.id
                        : connection.connecting.piece?.type.port?.id
                    const childPortId = connectedIsParent
                        ? connection.connecting.piece?.type.port?.id
                        : connection.connected.piece?.type.port?.id
                    const parentPort = ports
                        .get(parentPiece.type.name)
                        ?.get(parentPiece.type.variant ?? '')
                        ?.get(parentPortId ?? '')
                    const childPort = ports
                        .get(childPiece.type.name)
                        ?.get(childPiece.type.variant ?? '')
                        ?.get(childPortId ?? '')
                    const parentDirection = Vector.parse(parentPort.direction)
                    const childDirection = Vector.parse(childPort.direction)
                    const parentPoint = Point.parse(parentPort.point)
                    const childPoint = Point.parse(childPort.point)
                    const orient = Transform.fromDirections(childDirection.negate(), parentDirection)
                    let rotation = orient
                    if (connection.rotation !== 0) {
                        const rotate = Transform.fromAngle(parentDirection, connection.rotation)
                        rotation = rotate.after(orient)
                    }
                    const centerChild = childPoint.toVector().negate().toTransform()
                    const moveToParent = parentPoint.toVector().toTransform()
                    let transform = new Transform()
                    transform = rotation.after(centerChild)
                    if (connection.offset !== 0) {
                        const offset = parentDirection.clone().multiplyScalar(connection.offset).toTransform()
                        transform = offset.after(transform)
                    }
                    transform = moveToParent.after(transform)
                    const hierarchy = new Hierarchy(childPiece, transform)
                    // console.log(hierarchy, transform.toPlane(), rotation, centerChild, moveToParent)
                    pieceIdToHierarchy[childPiece.id] = hierarchy
                    pieceIdToHierarchy[parentPiece.id].children.push(hierarchy)
                }
            }
        )
        console.log(JSON.stringify(rootHierarchy))
    })
    return hierarchies
}
